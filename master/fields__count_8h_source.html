<!-- HTML header for doxygen 1.9.1--><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html class="dark-mode" xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/xhtml;charset=utf-8" http-equiv="Content-Type"/>
<meta content="noindex" name="robots"/>
<meta content="IE=9" http-equiv="X-UA-Compatible"/>
<meta content="Doxygen 1.13.1" name="generator"/>
<meta content="width=device-width, initial-scale=0.8" name="viewport"/>
<title>AUI Framework: aui.core/src/AUI/Reflect/detail/fields_count.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet"/>
<script src="jquery.js" type="text/javascript"></script>
<script src="dynsections.js" type="text/javascript"></script>
<script src="toc.js" type="text/javascript"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script src="navtreedata.js" type="text/javascript"></script>
<script src="navtree.js" type="text/javascript"></script>
<script src="resize.js" type="text/javascript"></script>
<script src="cookie.js" type="text/javascript"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script src="search/searchdata.js" type="text/javascript"></script>
<script src="search/search.js" type="text/javascript"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellpadding="0" cellspacing="0">
<tbody>
<tr style="height: 56px;">
<td id="projectlogo"><img alt="Logo" src="logo_doxygen.svg"/></td>
<td id="projectalign" style="padding-left: 0.5em;">
<div id="projectname">AUI Framework
                         <span id="projectnumber">master</span>
</div>
<div id="projectbrief">Cross-platform base for C++ UI apps</div>
</td>
</tr>
</tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script src="menudata.js" type="text/javascript"></script>
<script src="menu.js" type="text/javascript"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="ui-resizable side-nav-resizable" id="side-nav">
<div id="nav-tree">
<div id="nav-tree-contents">
<div class="sync" id="nav-sync"></div>
</div>
</div>
<div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;">
</div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('fields__count_8h_source.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>
<div class="header">
<div class="headertitle"><div class="title">fields_count.h</div></div>
</div><!--header-->
<div class="contents aui-toc-contents"><div class="contents-rails-left">
<div class="fragment"><div class="line"><a id="l00001" name="l00001"></a><span class="lineno">    1</span><span class="comment">/*</span></div>
<div class="line"><a id="l00002" name="l00002"></a><span class="lineno">    2</span><span class="comment"> * AUI Framework - Declarative UI toolkit for modern C++20</span></div>
<div class="line"><a id="l00003" name="l00003"></a><span class="lineno">    3</span><span class="comment"> * Copyright (C) 2020-2025 Alex2772 and Contributors</span></div>
<div class="line"><a id="l00004" name="l00004"></a><span class="lineno">    4</span><span class="comment"> *</span></div>
<div class="line"><a id="l00005" name="l00005"></a><span class="lineno">    5</span><span class="comment"> * SPDX-License-Identifier: MPL-2.0</span></div>
<div class="line"><a id="l00006" name="l00006"></a><span class="lineno">    6</span><span class="comment"> *</span></div>
<div class="line"><a id="l00007" name="l00007"></a><span class="lineno">    7</span><span class="comment"> * This Source Code Form is subject to the terms of the Mozilla Public</span></div>
<div class="line"><a id="l00008" name="l00008"></a><span class="lineno">    8</span><span class="comment"> * License, v. 2.0. If a copy of the MPL was not distributed with this</span></div>
<div class="line"><a id="l00009" name="l00009"></a><span class="lineno">    9</span><span class="comment"> * file, You can obtain one at http://mozilla.org/MPL/2.0/.</span></div>
<div class="line"><a id="l00010" name="l00010"></a><span class="lineno">   10</span><span class="comment"> */</span></div>
<div class="line"><a id="l00011" name="l00011"></a><span class="lineno">   11</span> </div>
<div class="line"><a id="l00012" name="l00012"></a><span class="lineno">   12</span><span class="preprocessor">#pragma once</span></div>
<div class="line"><a id="l00013" name="l00013"></a><span class="lineno">   13</span> </div>
<div class="line"><a id="l00014" name="l00014"></a><span class="lineno">   14</span><span class="preprocessor">#include &lt;cstdint&gt;</span></div>
<div class="line"><a id="l00015" name="l00015"></a><span class="lineno">   15</span><span class="preprocessor">#include &lt;type_traits&gt;</span></div>
<div class="line"><a id="l00016" name="l00016"></a><span class="lineno">   16</span><span class="preprocessor">#include &lt;limits&gt;</span></div>
<div class="line"><a id="l00017" name="l00017"></a><span class="lineno">   17</span><span class="preprocessor">#include "AUI/Traits/unsafe_declval.h"</span></div>
<div class="line"><a id="l00018" name="l00018"></a><span class="lineno">   18</span> </div>
<div class="line"><a id="l00019" name="l00019"></a><span class="lineno">   19</span><span class="keyword">namespace </span>aui::reflect::detail {</div>
<div class="line"><a id="l00020" name="l00020"></a><span class="lineno">   20</span> </div>
<div class="line"><a id="l00021" name="l00021"></a><span class="lineno">   21</span><span class="comment">// based on ideas found in Boost.PFR.</span></div>
<div class="line"><a id="l00022" name="l00022"></a><span class="lineno">   22</span><span class="comment">// credits: Antony Polukhin</span></div>
<div class="line"><a id="l00023" name="l00023"></a><span class="lineno">   23</span></div>
<div class="line"><a id="l00027" name="l00027"></a><span class="lineno">   27</span><span class="keyword">struct </span>lref_constructing {</div>
<div class="line"><a id="l00028" name="l00028"></a><span class="lineno">   28</span>    std::size_t ignore;</div>
<div class="line"><a id="l00029" name="l00029"></a><span class="lineno">   29</span>    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Type&gt;</div>
<div class="line"><a id="l00030" name="l00030"></a><span class="lineno">   30</span>    <span class="keyword">constexpr</span> <span class="keyword">operator</span> Type&amp;() <span class="keyword">const</span>&amp;&amp; <span class="keyword">noexcept</span> {</div>
<div class="line"><a id="l00031" name="l00031"></a><span class="lineno">   31</span>        <span class="keywordflow">return</span> aui::unsafe_declval&lt;Type&amp;&gt;();</div>
<div class="line"><a id="l00032" name="l00032"></a><span class="lineno">   32</span>    }</div>
<div class="line"><a id="l00033" name="l00033"></a><span class="lineno">   33</span> </div>
<div class="line"><a id="l00034" name="l00034"></a><span class="lineno">   34</span>    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Type&gt;</div>
<div class="line"><a id="l00035" name="l00035"></a><span class="lineno">   35</span>    <span class="keyword">constexpr</span> <span class="keyword">operator</span> Type&amp;() <span class="keyword">const</span>&amp; <span class="keyword">noexcept</span> {</div>
<div class="line"><a id="l00036" name="l00036"></a><span class="lineno">   36</span>        <span class="keywordflow">return</span> aui::unsafe_declval&lt;Type&amp;&gt;();</div>
<div class="line"><a id="l00037" name="l00037"></a><span class="lineno">   37</span>    }</div>
<div class="line"><a id="l00038" name="l00038"></a><span class="lineno">   38</span>};</div>
<div class="line"><a id="l00039" name="l00039"></a><span class="lineno">   39</span></div>
<div class="line"><a id="l00043" name="l00043"></a><span class="lineno">   43</span><span class="keyword">struct </span>rref_constructing {</div>
<div class="line"><a id="l00044" name="l00044"></a><span class="lineno">   44</span>    std::size_t ignore;</div>
<div class="line"><a id="l00045" name="l00045"></a><span class="lineno">   45</span>    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Type&gt;</div>
<div class="line"><a id="l00046" name="l00046"></a><span class="lineno">   46</span>    <span class="comment">/*constexpr*/</span></div>
<div class="line"><a id="l00047" name="l00047"></a><span class="lineno">   47</span>    <span class="keyword">operator</span> Type() const&amp;&amp; noexcept {   <span class="comment">// allows initialization of rvalue reference fields and move-only types</span></div>
<div class="line"><a id="l00048" name="l00048"></a><span class="lineno">   48</span>        <span class="keywordflow">return</span> aui::unsafe_declval&lt;Type&gt;();</div>
<div class="line"><a id="l00049" name="l00049"></a><span class="lineno">   49</span>    }</div>
<div class="line"><a id="l00050" name="l00050"></a><span class="lineno">   50</span>};</div>
<div class="line"><a id="l00051" name="l00051"></a><span class="lineno">   51</span></div>
<div class="line"><a id="l00055" name="l00055"></a><span class="lineno">   55</span><span class="keyword">template</span> &lt;</div>
<div class="line"><a id="l00056" name="l00056"></a><span class="lineno">   56</span>    <span class="keyword">class </span>T, std::size_t... I, <span class="keyword">class </span><span class="comment">/*Enable*/</span> = <span class="keyword">typename</span> std::enable_if&lt;std::is_copy_constructible&lt;T&gt;::value&gt;::type&gt;</div>
<div class="line"><a id="l00057" name="l00057"></a><span class="lineno">   57</span><span class="keyword">constexpr</span> <span class="keyword">auto</span> enable_if_constructible(std::index_sequence&lt;I...&gt;) <span class="keyword">noexcept</span> -&gt; <span class="keyword">typename</span> std::add_pointer&lt;<span class="keyword">decltype</span>(T {</div>
<div class="line"><a id="l00058" name="l00058"></a><span class="lineno">   58</span>  lref_constructing { I }... })&gt;::type;</div>
<div class="line"><a id="l00059" name="l00059"></a><span class="lineno">   59</span> </div>
<div class="line"><a id="l00060" name="l00060"></a><span class="lineno">   60</span><span class="keyword">template</span> &lt;</div>
<div class="line"><a id="l00061" name="l00061"></a><span class="lineno">   61</span>    <span class="keyword">class </span>T, std::size_t... I, <span class="keyword">class </span><span class="comment">/*Enable*/</span> = <span class="keyword">typename</span> std::enable_if&lt;!std::is_copy_constructible&lt;T&gt;::value&gt;::type&gt;</div>
<div class="line"><a id="l00062" name="l00062"></a><span class="lineno">   62</span><span class="keyword">constexpr</span> <span class="keyword">auto</span> enable_if_constructible(std::index_sequence&lt;I...&gt;) <span class="keyword">noexcept</span> -&gt; <span class="keyword">typename</span> std::add_pointer&lt;<span class="keyword">decltype</span>(T {</div>
<div class="line"><a id="l00063" name="l00063"></a><span class="lineno">   63</span>  rref_constructing { I }... })&gt;::type;</div>
<div class="line"><a id="l00064" name="l00064"></a><span class="lineno">   64</span> </div>
<div class="line"><a id="l00065" name="l00065"></a><span class="lineno">   65</span><span class="keyword">template</span> &lt;</div>
<div class="line"><a id="l00066" name="l00066"></a><span class="lineno">   66</span>    <span class="keyword">class </span>T, std::size_t N,</div>
<div class="line"><a id="l00067" name="l00067"></a><span class="lineno">   67</span>    <span class="keyword">class </span><span class="comment">/*Enable*/</span> = <span class="keyword">decltype</span>(enable_if_constructible&lt;T&gt;(std::make_integer_sequence&lt;std::size_t, N&gt;()))&gt;</div>
<div class="line"><a id="l00068" name="l00068"></a><span class="lineno">   68</span><span class="keyword">using</span> enable_if_constructible_t = std::size_t;</div>
<div class="line"><a id="l00069" name="l00069"></a><span class="lineno">   69</span></div>
<div class="line"><a id="l00075" name="l00075"></a><span class="lineno">   75</span><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, std::<span class="keywordtype">size_t</span> N&gt;</div>
<div class="line"><a id="l00076" name="l00076"></a><span class="lineno">   76</span><span class="keyword">constexpr</span> <span class="keyword">auto</span> detect_fields_count_greedy_remember(<span class="keywordtype">long</span>) <span class="keyword">noexcept</span> -&gt; detail::enable_if_constructible_t&lt;T, N&gt; {</div>
<div class="line"><a id="l00077" name="l00077"></a><span class="lineno">   77</span>    <span class="keywordflow">return</span> N;</div>
<div class="line"><a id="l00078" name="l00078"></a><span class="lineno">   78</span>}</div>
<div class="line"><a id="l00079" name="l00079"></a><span class="lineno">   79</span> </div>
<div class="line"><a id="l00080" name="l00080"></a><span class="lineno">   80</span><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, std::<span class="keywordtype">size_t</span> N&gt;</div>
<div class="line"><a id="l00081" name="l00081"></a><span class="lineno">   81</span><span class="keyword">constexpr</span> std::size_t detect_fields_count_greedy_remember(<span class="keywordtype">int</span>) <span class="keyword">noexcept</span> {</div>
<div class="line"><a id="l00082" name="l00082"></a><span class="lineno">   82</span>    <span class="keywordflow">return</span> 0;</div>
<div class="line"><a id="l00083" name="l00083"></a><span class="lineno">   83</span>}</div>
<div class="line"><a id="l00084" name="l00084"></a><span class="lineno">   84</span> </div>
<div class="line"><a id="l00085" name="l00085"></a><span class="lineno">   85</span><span class="keyword">using </span>multi_element_range = std::false_type;</div>
<div class="line"><a id="l00086" name="l00086"></a><span class="lineno">   86</span><span class="keyword">using </span>one_element_range = std::true_type;</div>
<div class="line"><a id="l00087" name="l00087"></a><span class="lineno">   87</span> </div>
<div class="line"><a id="l00088" name="l00088"></a><span class="lineno">   88</span><span class="keyword">template</span> &lt;std::<span class="keywordtype">size_t</span> Begin, std::<span class="keywordtype">size_t</span> Last&gt;</div>
<div class="line"><a id="l00089" name="l00089"></a><span class="lineno">   89</span><span class="keyword">using </span>is_one_element_range = std::integral_constant&lt;bool, Begin == Last&gt;;</div>
<div class="line"><a id="l00090" name="l00090"></a><span class="lineno">   90</span> </div>
<div class="line"><a id="l00091" name="l00091"></a><span class="lineno">   91</span><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, std::<span class="keywordtype">size_t</span> Begin, std::<span class="keywordtype">size_t</span> Last&gt;</div>
<div class="line"><a id="l00092" name="l00092"></a><span class="lineno">   92</span><span class="keyword">constexpr</span> std::size_t detect_fields_count_greedy(detail::one_element_range) <span class="keyword">noexcept</span> {</div>
<div class="line"><a id="l00093" name="l00093"></a><span class="lineno">   93</span>    <span class="keyword">static_assert</span>(</div>
<div class="line"><a id="l00094" name="l00094"></a><span class="lineno">   94</span>        Begin == Last,</div>
<div class="line"><a id="l00095" name="l00095"></a><span class="lineno">   95</span>        <span class="stringliteral">"====================&gt; aui::reflect: internal logic error. Please report this issue to the github along with the "</span></div>
<div class="line"><a id="l00096" name="l00096"></a><span class="lineno">   96</span>        <span class="stringliteral">"structure you're reflecting."</span>);</div>
<div class="line"><a id="l00097" name="l00097"></a><span class="lineno">   97</span>    <span class="keywordflow">return</span> detail::detect_fields_count_greedy_remember&lt;T, Begin&gt;(1L);</div>
<div class="line"><a id="l00098" name="l00098"></a><span class="lineno">   98</span>}</div>
<div class="line"><a id="l00099" name="l00099"></a><span class="lineno">   99</span> </div>
<div class="line"><a id="l00100" name="l00100"></a><span class="lineno">  100</span><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, std::<span class="keywordtype">size_t</span> Begin, std::<span class="keywordtype">size_t</span> Last&gt;</div>
<div class="line"><a id="l00101" name="l00101"></a><span class="lineno">  101</span><span class="keyword">constexpr</span> std::size_t detect_fields_count_greedy(detail::multi_element_range) <span class="keyword">noexcept</span> {</div>
<div class="line"><a id="l00102" name="l00102"></a><span class="lineno">  102</span>    <span class="keyword">constexpr</span> std::size_t middle = Begin + (Last - Begin) / 2;</div>
<div class="line"><a id="l00103" name="l00103"></a><span class="lineno">  103</span>    <span class="keyword">constexpr</span> std::size_t fields_count_big_range =</div>
<div class="line"><a id="l00104" name="l00104"></a><span class="lineno">  104</span>        detail::detect_fields_count_greedy&lt;T, middle + 1, Last&gt;(detail::is_one_element_range&lt;middle + 1, Last&gt; {});</div>
<div class="line"><a id="l00105" name="l00105"></a><span class="lineno">  105</span> </div>
<div class="line"><a id="l00106" name="l00106"></a><span class="lineno">  106</span>    <span class="keyword">constexpr</span> std::size_t small_range_begin = (fields_count_big_range ? 0 : Begin);</div>
<div class="line"><a id="l00107" name="l00107"></a><span class="lineno">  107</span>    <span class="keyword">constexpr</span> std::size_t small_range_last = (fields_count_big_range ? 0 : middle);</div>
<div class="line"><a id="l00108" name="l00108"></a><span class="lineno">  108</span>    <span class="keyword">constexpr</span> std::size_t fields_count_small_range = detail::detect_fields_count_greedy&lt;</div>
<div class="line"><a id="l00109" name="l00109"></a><span class="lineno">  109</span>        T, small_range_begin, small_range_last&gt;(detail::is_one_element_range&lt;small_range_begin, small_range_last&gt; {});</div>
<div class="line"><a id="l00110" name="l00110"></a><span class="lineno">  110</span>    <span class="keywordflow">return</span> fields_count_big_range ? fields_count_big_range : fields_count_small_range;</div>
<div class="line"><a id="l00111" name="l00111"></a><span class="lineno">  111</span>}</div>
<div class="line"><a id="l00112" name="l00112"></a><span class="lineno">  112</span></div>
<div class="line"><a id="l00122" name="l00122"></a><span class="lineno">  122</span><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, std::<span class="keywordtype">size_t</span> Begin, std::<span class="keywordtype">size_t</span> M<span class="keywordtype">id</span>dle&gt;</div>
<div class="line"><a id="l00123" name="l00123"></a><span class="lineno">  123</span><span class="keyword">constexpr</span> std::size_t detect_fields_count(detail::one_element_range, <span class="keywordtype">long</span>) <span class="keyword">noexcept</span> {</div>
<div class="line"><a id="l00124" name="l00124"></a><span class="lineno">  124</span>    <span class="keyword">static_assert</span>(</div>
<div class="line"><a id="l00125" name="l00125"></a><span class="lineno">  125</span>        Begin == Middle,</div>
<div class="line"><a id="l00126" name="l00126"></a><span class="lineno">  126</span>        <span class="stringliteral">"====================&gt; aui::reflect: internal logic error. Please report this issue to the github along with the "</span></div>
<div class="line"><a id="l00127" name="l00127"></a><span class="lineno">  127</span>        <span class="stringliteral">"structure you're reflecting."</span>);</div>
<div class="line"><a id="l00128" name="l00128"></a><span class="lineno">  128</span>    <span class="keywordflow">return</span> Begin;</div>
<div class="line"><a id="l00129" name="l00129"></a><span class="lineno">  129</span>}</div>
<div class="line"><a id="l00130" name="l00130"></a><span class="lineno">  130</span> </div>
<div class="line"><a id="l00131" name="l00131"></a><span class="lineno">  131</span><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, std::<span class="keywordtype">size_t</span> Begin, std::<span class="keywordtype">size_t</span> M<span class="keywordtype">id</span>dle&gt;</div>
<div class="line"><a id="l00132" name="l00132"></a><span class="lineno">  132</span><span class="keyword">constexpr</span> std::size_t detect_fields_count(detail::multi_element_range, <span class="keywordtype">int</span>) <span class="keyword">noexcept</span>;</div>
<div class="line"><a id="l00133" name="l00133"></a><span class="lineno">  133</span> </div>
<div class="line"><a id="l00134" name="l00134"></a><span class="lineno">  134</span><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, std::<span class="keywordtype">size_t</span> Begin, std::<span class="keywordtype">size_t</span> M<span class="keywordtype">id</span>dle&gt;</div>
<div class="line"><a id="l00135" name="l00135"></a><span class="lineno">  135</span><span class="keyword">constexpr</span> <span class="keyword">auto</span></div>
<div class="line"><a id="l00136" name="l00136"></a><span class="lineno">  136</span>detect_fields_count(detail::multi_element_range, <span class="keywordtype">long</span>) <span class="keyword">noexcept</span> -&gt; detail::enable_if_constructible_t&lt;T, Middle&gt; {</div>
<div class="line"><a id="l00137" name="l00137"></a><span class="lineno">  137</span>    <span class="keyword">constexpr</span> std::size_t next_v = Middle + (Middle - Begin + 1) / 2;</div>
<div class="line"><a id="l00138" name="l00138"></a><span class="lineno">  138</span>    <span class="keywordflow">return</span> detail::detect_fields_count&lt;T, Middle, next_v&gt;(detail::is_one_element_range&lt;Middle, next_v&gt; {}, 1L);</div>
<div class="line"><a id="l00139" name="l00139"></a><span class="lineno">  139</span>}</div>
<div class="line"><a id="l00140" name="l00140"></a><span class="lineno">  140</span> </div>
<div class="line"><a id="l00141" name="l00141"></a><span class="lineno">  141</span><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, std::<span class="keywordtype">size_t</span> Begin, std::<span class="keywordtype">size_t</span> M<span class="keywordtype">id</span>dle&gt;</div>
<div class="line"><a id="l00142" name="l00142"></a><span class="lineno">  142</span><span class="keyword">constexpr</span> std::size_t detect_fields_count(detail::multi_element_range, <span class="keywordtype">int</span>) <span class="keyword">noexcept</span> {</div>
<div class="line"><a id="l00143" name="l00143"></a><span class="lineno">  143</span>    <span class="keyword">constexpr</span> std::size_t next_v = Begin + (Middle - Begin) / 2;</div>
<div class="line"><a id="l00144" name="l00144"></a><span class="lineno">  144</span>    <span class="keywordflow">return</span> detail::detect_fields_count&lt;T, Begin, next_v&gt;(detail::is_one_element_range&lt;Begin, next_v&gt; {}, 1L);</div>
<div class="line"><a id="l00145" name="l00145"></a><span class="lineno">  145</span>}</div>
<div class="line"><a id="l00146" name="l00146"></a><span class="lineno">  146</span></div>
<div class="line"><a id="l00153" name="l00153"></a><span class="lineno">  153</span><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, std::<span class="keywordtype">size_t</span> N&gt;</div>
<div class="line"><a id="l00154" name="l00154"></a><span class="lineno">  154</span><span class="keyword">constexpr</span> <span class="keyword">auto</span> detect_fields_count_dispatch(std::integral_constant&lt;std::size_t, N&gt;, <span class="keywordtype">long</span>, <span class="keywordtype">long</span>) <span class="keyword">noexcept</span> -&gt;</div>
<div class="line"><a id="l00155" name="l00155"></a><span class="lineno">  155</span>    <span class="keyword">typename</span> std::enable_if&lt;std::is_array&lt;T&gt;::value, std::size_t&gt;::type {</div>
<div class="line"><a id="l00156" name="l00156"></a><span class="lineno">  156</span>    <span class="keywordflow">return</span> <span class="keyword">sizeof</span>(T) / <span class="keyword">sizeof</span>(<span class="keyword">typename</span> std::remove_all_extents&lt;T&gt;::type);</div>
<div class="line"><a id="l00157" name="l00157"></a><span class="lineno">  157</span>}</div>
<div class="line"><a id="l00158" name="l00158"></a><span class="lineno">  158</span> </div>
<div class="line"><a id="l00159" name="l00159"></a><span class="lineno">  159</span><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, std::<span class="keywordtype">size_t</span> N&gt;</div>
<div class="line"><a id="l00160" name="l00160"></a><span class="lineno">  160</span><span class="keyword">constexpr</span> <span class="keyword">auto</span></div>
<div class="line"><a id="l00161" name="l00161"></a><span class="lineno">  161</span>detect_fields_count_dispatch(std::integral_constant&lt;std::size_t, N&gt;, <span class="keywordtype">long</span>, <span class="keywordtype">int</span>) <span class="keyword">noexcept</span> -&gt; <span class="keyword">decltype</span>(<span class="keyword">sizeof</span>(T {})) {</div>
<div class="line"><a id="l00162" name="l00162"></a><span class="lineno">  162</span>    <span class="keyword">constexpr</span> std::size_t middle = N / 2 + 1;</div>
<div class="line"><a id="l00163" name="l00163"></a><span class="lineno">  163</span>    <span class="keywordflow">return</span> detail::detect_fields_count&lt;T, 0, middle&gt;(detail::multi_element_range {}, 1L);</div>
<div class="line"><a id="l00164" name="l00164"></a><span class="lineno">  164</span>}</div>
<div class="line"><a id="l00165" name="l00165"></a><span class="lineno">  165</span> </div>
<div class="line"><a id="l00166" name="l00166"></a><span class="lineno">  166</span><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, std::<span class="keywordtype">size_t</span> N&gt;</div>
<div class="line"><a id="l00167" name="l00167"></a><span class="lineno">  167</span><span class="keyword">constexpr</span> std::size_t detect_fields_count_dispatch(std::integral_constant&lt;std::size_t, N&gt;, <span class="keywordtype">int</span>, <span class="keywordtype">int</span>) <span class="keyword">noexcept</span> {</div>
<div class="line"><a id="l00168" name="l00168"></a><span class="lineno">  168</span>    <span class="comment">// Detects the maximum number of default-constructible members in struct type T.</span></div>
<div class="line"><a id="l00169" name="l00169"></a><span class="lineno">  169</span>    <span class="comment">// This is necessary because T, being non-default aggregate initializable,</span></div>
<div class="line"><a id="l00170" name="l00170"></a><span class="lineno">  170</span>    <span class="comment">// has at least one member that isn't default constructible.</span></div>
<div class="line"><a id="l00171" name="l00171"></a><span class="lineno">  171</span>    <span class="comment">//</span></div>
<div class="line"><a id="l00172" name="l00172"></a><span class="lineno">  172</span>    <span class="comment">// We must manually check each constructor up to N parameters and return</span></div>
<div class="line"><a id="l00173" name="l00173"></a><span class="lineno">  173</span>    <span class="comment">// the largest one that doesn't result in a compile-time error.</span></div>
<div class="line"><a id="l00174" name="l00174"></a><span class="lineno">  174</span>    <span class="keywordflow">return</span> detail::detect_fields_count_greedy&lt;T, 0, N&gt;(detail::multi_element_range {});</div>
<div class="line"><a id="l00175" name="l00175"></a><span class="lineno">  175</span>}</div>
<div class="line"><a id="l00176" name="l00176"></a><span class="lineno">  176</span></div>
<div class="line"><a id="l00180" name="l00180"></a><span class="lineno">  180</span><span class="keyword">template</span> &lt;<span class="keyword">class</span> Derived, <span class="keyword">class</span> U&gt;</div>
<div class="line"><a id="l00181" name="l00181"></a><span class="lineno">  181</span><span class="keyword">constexpr</span> <span class="keywordtype">bool</span> static_assert_non_inherited() noexcept {</div>
<div class="line"><a id="l00182" name="l00182"></a><span class="lineno">  182</span>    <span class="keyword">static_assert</span>(</div>
<div class="line"><a id="l00183" name="l00183"></a><span class="lineno">  183</span>        !std::is_base_of&lt;U, Derived&gt;::value, <span class="stringliteral">"====================&gt; aui::reflect: inherited types are not supported."</span>);</div>
<div class="line"><a id="l00184" name="l00184"></a><span class="lineno">  184</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a id="l00185" name="l00185"></a><span class="lineno">  185</span>}</div>
<div class="line"><a id="l00186" name="l00186"></a><span class="lineno">  186</span> </div>
<div class="line"><a id="l00187" name="l00187"></a><span class="lineno">  187</span><span class="keyword">template</span> &lt;<span class="keyword">class</span> Derived&gt;</div>
<div class="line"><a id="l00188" name="l00188"></a><span class="lineno">  188</span><span class="keyword">struct </span>lref_base_asserting {</div>
<div class="line"><a id="l00189" name="l00189"></a><span class="lineno">  189</span>    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Type&gt;</div>
<div class="line"><a id="l00190" name="l00190"></a><span class="lineno">  190</span>    <span class="keyword">constexpr</span> <span class="keyword">operator</span> Type&amp;() <span class="keyword">const</span>&amp;&amp;   <span class="comment">// tweak for template_unconstrained.cpp like cases</span></div>
<div class="line"><a id="l00191" name="l00191"></a><span class="lineno">  191</span>        <span class="keyword">noexcept</span>(detail::static_assert_non_inherited&lt;Derived, Type&gt;())   <span class="comment">// force the computation of assert function</span></div>
<div class="line"><a id="l00192" name="l00192"></a><span class="lineno">  192</span>    {</div>
<div class="line"><a id="l00193" name="l00193"></a><span class="lineno">  193</span>        <span class="keywordflow">return</span> aui::unsafe_declval&lt;Type&amp;&gt;();</div>
<div class="line"><a id="l00194" name="l00194"></a><span class="lineno">  194</span>    }</div>
<div class="line"><a id="l00195" name="l00195"></a><span class="lineno">  195</span> </div>
<div class="line"><a id="l00196" name="l00196"></a><span class="lineno">  196</span>    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Type&gt;</div>
<div class="line"><a id="l00197" name="l00197"></a><span class="lineno">  197</span>    <span class="keyword">constexpr</span> <span class="keyword">operator</span> Type&amp;() <span class="keyword">const</span>&amp;                                    <span class="comment">// tweak for optional_chrono.cpp like cases</span></div>
<div class="line"><a id="l00198" name="l00198"></a><span class="lineno">  198</span>        <span class="keyword">noexcept</span>(detail::static_assert_non_inherited&lt;Derived, Type&gt;())   <span class="comment">// force the computation of assert function</span></div>
<div class="line"><a id="l00199" name="l00199"></a><span class="lineno">  199</span>    {</div>
<div class="line"><a id="l00200" name="l00200"></a><span class="lineno">  200</span>        <span class="keywordflow">return</span> aui::unsafe_declval&lt;Type&amp;&gt;();</div>
<div class="line"><a id="l00201" name="l00201"></a><span class="lineno">  201</span>    }</div>
<div class="line"><a id="l00202" name="l00202"></a><span class="lineno">  202</span>};</div>
<div class="line"><a id="l00203" name="l00203"></a><span class="lineno">  203</span> </div>
<div class="line"><a id="l00204" name="l00204"></a><span class="lineno">  204</span><span class="keyword">template</span> &lt;<span class="keyword">class</span> Derived&gt;</div>
<div class="line"><a id="l00205" name="l00205"></a><span class="lineno">  205</span><span class="keyword">struct </span>rref_base_asserting {</div>
<div class="line"><a id="l00206" name="l00206"></a><span class="lineno">  206</span>    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Type&gt;</div>
<div class="line"><a id="l00207" name="l00207"></a><span class="lineno">  207</span>    <span class="comment">/*constexpr*/</span> <span class="keyword">operator</span> Type() const&amp;&amp;   <span class="comment">// Allows initialization of rvalue reference fields and move-only types</span></div>
<div class="line"><a id="l00208" name="l00208"></a><span class="lineno">  208</span>        noexcept(detail::static_assert_non_inherited&lt;Derived, Type&gt;())   <span class="comment">// force the computation of assert function</span></div>
<div class="line"><a id="l00209" name="l00209"></a><span class="lineno">  209</span>    {</div>
<div class="line"><a id="l00210" name="l00210"></a><span class="lineno">  210</span>        <span class="keywordflow">return</span> aui::unsafe_declval&lt;Type&gt;();</div>
<div class="line"><a id="l00211" name="l00211"></a><span class="lineno">  211</span>    }</div>
<div class="line"><a id="l00212" name="l00212"></a><span class="lineno">  212</span>};</div>
<div class="line"><a id="l00213" name="l00213"></a><span class="lineno">  213</span> </div>
<div class="line"><a id="l00214" name="l00214"></a><span class="lineno">  214</span><span class="keyword">template</span> &lt;</div>
<div class="line"><a id="l00215" name="l00215"></a><span class="lineno">  215</span>    <span class="keyword">class </span>T, std::size_t I0, std::size_t... I,</div>
<div class="line"><a id="l00216" name="l00216"></a><span class="lineno">  216</span>    <span class="keyword">class </span><span class="comment">/*Enable*/</span> = <span class="keyword">typename</span> std::enable_if&lt;std::is_copy_constructible&lt;T&gt;::value&gt;::type&gt;</div>
<div class="line"><a id="l00217" name="l00217"></a><span class="lineno">  217</span><span class="keyword">constexpr</span> <span class="keyword">auto</span></div>
<div class="line"><a id="l00218" name="l00218"></a><span class="lineno">  218</span>assert_first_is_not_base(std::index_sequence&lt;I0, I...&gt;) <span class="keyword">noexcept</span> -&gt; <span class="keyword">typename</span> std::add_pointer&lt;<span class="keyword">decltype</span>(T {</div>
<div class="line"><a id="l00219" name="l00219"></a><span class="lineno">  219</span>  lref_base_asserting&lt;T&gt; {}, lref_constructing { I }... })&gt;::type {</div>
<div class="line"><a id="l00220" name="l00220"></a><span class="lineno">  220</span>    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line"><a id="l00221" name="l00221"></a><span class="lineno">  221</span>}</div>
<div class="line"><a id="l00222" name="l00222"></a><span class="lineno">  222</span> </div>
<div class="line"><a id="l00223" name="l00223"></a><span class="lineno">  223</span><span class="keyword">template</span> &lt;</div>
<div class="line"><a id="l00224" name="l00224"></a><span class="lineno">  224</span>    <span class="keyword">class </span>T, std::size_t I0, std::size_t... I,</div>
<div class="line"><a id="l00225" name="l00225"></a><span class="lineno">  225</span>    <span class="keyword">class </span><span class="comment">/*Enable*/</span> = <span class="keyword">typename</span> std::enable_if&lt;!std::is_copy_constructible&lt;T&gt;::value&gt;::type&gt;</div>
<div class="line"><a id="l00226" name="l00226"></a><span class="lineno">  226</span><span class="keyword">constexpr</span> <span class="keyword">auto</span></div>
<div class="line"><a id="l00227" name="l00227"></a><span class="lineno">  227</span>assert_first_is_not_base(std::index_sequence&lt;I0, I...&gt;) <span class="keyword">noexcept</span> -&gt; <span class="keyword">typename</span> std::add_pointer&lt;<span class="keyword">decltype</span>(T {</div>
<div class="line"><a id="l00228" name="l00228"></a><span class="lineno">  228</span>  rref_base_asserting&lt;T&gt; {}, rref_constructing { I }... })&gt;::type {</div>
<div class="line"><a id="l00229" name="l00229"></a><span class="lineno">  229</span>    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line"><a id="l00230" name="l00230"></a><span class="lineno">  230</span>}</div>
<div class="line"><a id="l00231" name="l00231"></a><span class="lineno">  231</span> </div>
<div class="line"><a id="l00232" name="l00232"></a><span class="lineno">  232</span><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div>
<div class="line"><a id="l00233" name="l00233"></a><span class="lineno">  233</span><span class="keyword">constexpr</span> <span class="keywordtype">void</span>* assert_first_is_not_base(std::index_sequence&lt;&gt;) <span class="keyword">noexcept</span> {</div>
<div class="line"><a id="l00234" name="l00234"></a><span class="lineno">  234</span>    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line"><a id="l00235" name="l00235"></a><span class="lineno">  235</span>}</div>
<div class="line"><a id="l00236" name="l00236"></a><span class="lineno">  236</span></div>
<div class="line"><a id="l00246" name="l00246"></a><span class="lineno">  246</span><span class="keyword">template</span> &lt;<span class="keyword">class</span> Clazz&gt;</div>
<div class="line"><a id="l00247" name="l00247"></a><span class="lineno">  247</span><span class="keyword">constexpr</span> std::size_t fields_count() noexcept {</div>
<div class="line"><a id="l00248" name="l00248"></a><span class="lineno">  248</span>    <span class="keyword">using </span>type = std::remove_cv_t&lt;Clazz&gt;;</div>
<div class="line"><a id="l00249" name="l00249"></a><span class="lineno">  249</span> </div>
<div class="line"><a id="l00250" name="l00250"></a><span class="lineno">  250</span>    <span class="keyword">static_assert</span>(</div>
<div class="line"><a id="l00251" name="l00251"></a><span class="lineno">  251</span>        !std::is_reference&lt;type&gt;::value, <span class="stringliteral">"====================&gt; aui::reflect: attempt to get fields count on a reference."</span>);</div>
<div class="line"><a id="l00252" name="l00252"></a><span class="lineno">  252</span> </div>
<div class="line"><a id="l00253" name="l00253"></a><span class="lineno">  253</span>    <span class="keyword">static_assert</span>(</div>
<div class="line"><a id="l00254" name="l00254"></a><span class="lineno">  254</span>        !std::is_polymorphic&lt;type&gt;::value,</div>
<div class="line"><a id="l00255" name="l00255"></a><span class="lineno">  255</span>        <span class="stringliteral">"====================&gt; aui::reflect: type must have no virtual function, because otherwise it is not aggregate "</span></div>
<div class="line"><a id="l00256" name="l00256"></a><span class="lineno">  256</span>        <span class="stringliteral">"initializable."</span>);</div>
<div class="line"><a id="l00257" name="l00257"></a><span class="lineno">  257</span> </div>
<div class="line"><a id="l00258" name="l00258"></a><span class="lineno">  258</span><span class="preprocessor">#ifdef __cpp_lib_is_aggregate</span></div>
<div class="line"><a id="l00259" name="l00259"></a><span class="lineno">  259</span>    <span class="keyword">static_assert</span>(</div>
<div class="line"><a id="l00260" name="l00260"></a><span class="lineno">  260</span>        std::is_aggregate&lt;type&gt;::value || std::is_scalar&lt;type&gt;::value,</div>
<div class="line"><a id="l00261" name="l00261"></a><span class="lineno">  261</span>        <span class="stringliteral">"====================&gt; aui::reflect: type must be aggregate initializable."</span>);</div>
<div class="line"><a id="l00262" name="l00262"></a><span class="lineno">  262</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l00263" name="l00263"></a><span class="lineno">  263</span> </div>
<div class="line"><a id="l00264" name="l00264"></a><span class="lineno">  264</span><span class="preprocessor">#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &lt;= 1920)</span></div>
<div class="line"><a id="l00265" name="l00265"></a><span class="lineno">  265</span>    <span class="comment">// workaround for msvc compilers. versions &lt;= 1920 have a limit of max 1024 elements in template parameter pack</span></div>
<div class="line"><a id="l00266" name="l00266"></a><span class="lineno">  266</span>    <span class="keyword">constexpr</span> std::size_t max_fields_count = (<span class="keyword">sizeof</span>(type) * CHAR_BIT &gt;= 1024 ? 1024 : <span class="keyword">sizeof</span>(type) * CHAR_BIT);</div>
<div class="line"><a id="l00267" name="l00267"></a><span class="lineno">  267</span><span class="preprocessor">#else</span></div>
<div class="line"><a id="l00268" name="l00268"></a><span class="lineno">  268</span>    <span class="keyword">constexpr</span> std::size_t max_fields_count = (<span class="keyword">sizeof</span>(type) * CHAR_BIT);   <span class="comment">// we multiply by CHAR_BIT because the type</span></div>
<div class="line"><a id="l00269" name="l00269"></a><span class="lineno">  269</span>                                                                          <span class="comment">// may have bitfields in T</span></div>
<div class="line"><a id="l00270" name="l00270"></a><span class="lineno">  270</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l00271" name="l00271"></a><span class="lineno">  271</span> </div>
<div class="line"><a id="l00272" name="l00272"></a><span class="lineno">  272</span>    <span class="keyword">constexpr</span> std::size_t result =</div>
<div class="line"><a id="l00273" name="l00273"></a><span class="lineno">  273</span>        detail::detect_fields_count_dispatch&lt;type&gt;(std::integral_constant&lt;std::size_t, max_fields_count&gt; {}, 1L, 1L);</div>
<div class="line"><a id="l00274" name="l00274"></a><span class="lineno">  274</span> </div>
<div class="line"><a id="l00275" name="l00275"></a><span class="lineno">  275</span>    detail::assert_first_is_not_base&lt;type&gt;(std::make_integer_sequence&lt;std::size_t, result&gt;());</div>
<div class="line"><a id="l00276" name="l00276"></a><span class="lineno">  276</span> </div>
<div class="line"><a id="l00277" name="l00277"></a><span class="lineno">  277</span><span class="preprocessor">#ifndef __cpp_lib_is_aggregate</span></div>
<div class="line"><a id="l00278" name="l00278"></a><span class="lineno">  278</span>    <span class="keyword">static_assert</span>(</div>
<div class="line"><a id="l00279" name="l00279"></a><span class="lineno">  279</span>        is_aggregate_initializable_n&lt;type, result&gt;::value,</div>
<div class="line"><a id="l00280" name="l00280"></a><span class="lineno">  280</span>        <span class="stringliteral">"====================&gt; aui::reflect: types with user specified constructors (non-aggregate initializable types) "</span></div>
<div class="line"><a id="l00281" name="l00281"></a><span class="lineno">  281</span>        <span class="stringliteral">"are not supported."</span>);</div>
<div class="line"><a id="l00282" name="l00282"></a><span class="lineno">  282</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l00283" name="l00283"></a><span class="lineno">  283</span> </div>
<div class="line"><a id="l00284" name="l00284"></a><span class="lineno">  284</span>    <span class="keyword">static_assert</span>(</div>
<div class="line"><a id="l00285" name="l00285"></a><span class="lineno">  285</span>        result != 0 || std::is_empty&lt;type&gt;::value || std::is_fundamental&lt;type&gt;::value || std::is_reference&lt;type&gt;::value,</div>
<div class="line"><a id="l00286" name="l00286"></a><span class="lineno">  286</span>        <span class="stringliteral">"====================&gt; aui::reflect: if there's no other failed static asserts then something went wrong. Please "</span></div>
<div class="line"><a id="l00287" name="l00287"></a><span class="lineno">  287</span>        <span class="stringliteral">"report this issue to the github along with the structure you're reflecting."</span>);</div>
<div class="line"><a id="l00288" name="l00288"></a><span class="lineno">  288</span> </div>
<div class="line"><a id="l00289" name="l00289"></a><span class="lineno">  289</span>    <span class="keywordflow">return</span> result;</div>
<div class="line"><a id="l00290" name="l00290"></a><span class="lineno">  290</span>}</div>
<div class="line"><a id="l00291" name="l00291"></a><span class="lineno">  291</span>}   <span class="comment">// namespace aui::reflect::detail</span></div>
</div><!-- fragment --><p class="footer-inner">
    © 2025 AUI Framework Contributors. Documentation contributions included herein are the copyrights of their
    respective owners. The documentation provided herein is licensed under the terms of the GNU Free Documentation
    License version 1.3 as published by the Free Software Foundation. All trademarks are property of their respective owners.
</p>
</div><div class="contents-rails-right"></div></div><!-- doc-content -->
<!-- HTML footer for doxygen 1.12.0-->
<!-- start footer part -->
</div></body>
</html>
