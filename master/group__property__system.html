<!-- HTML header for doxygen 1.9.1--><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html class="dark-mode" xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/xhtml;charset=utf-8" http-equiv="Content-Type"/>
<meta content="IE=9" http-equiv="X-UA-Compatible"/>
<meta content="Doxygen 1.13.1" name="generator"/>
<meta content="width=device-width, initial-scale=0.8" name="viewport"/>
<title>AUI Framework: Property System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet"/>
<script src="jquery.js" type="text/javascript"></script>
<script src="dynsections.js" type="text/javascript"></script>
<script src="toc.js" type="text/javascript"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script src="navtreedata.js" type="text/javascript"></script>
<script src="navtree.js" type="text/javascript"></script>
<script src="resize.js" type="text/javascript"></script>
<script src="cookie.js" type="text/javascript"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script src="search/searchdata.js" type="text/javascript"></script>
<script src="search/search.js" type="text/javascript"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellpadding="0" cellspacing="0">
<tbody>
<tr style="height: 56px;">
<td id="projectlogo"><img alt="Logo" src="logo_doxygen.svg"/></td>
<td id="projectalign" style="padding-left: 0.5em;">
<div id="projectname">AUI Framework
                         <span id="projectnumber">master</span>
</div>
<div id="projectbrief">Cross-platform base for C++ UI apps</div>
</td>
</tr>
</tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script src="menudata.js" type="text/javascript"></script>
<script src="menu.js" type="text/javascript"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="ui-resizable side-nav-resizable" id="side-nav">
<div id="nav-tree">
<div id="nav-tree-contents">
<div class="sync" id="nav-sync"></div>
</div>
</div>
<div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;">
</div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group__property__system.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>
<div class="header">
<div class="summary"><a href="javascript:jumpToSource('view')">View Page Source</a> | <a href="javascript:jumpToSource('edit')">Edit Page Source</a> | 
<a href="#nested-classes">Classes</a> </div>
<div class="headertitle"><div class="title">Property System<div class="ingroups"><a class="el" href="group__core.html">aui::core</a></div></div></div>
</div><!--header-->
<div class="contents aui-toc-contents"><div class="contents-rails-left"><b aui-src="doxygen/intermediate/properties.h#L9"></b>
<p>Property System is a data binding mechanism based on <a class="el" href="group__signal__slot.html">signal-slot system</a>.  
<a href="#details">More...</a></p>
<a id="details" name="details"></a><h2 class="groupheader">Detailed Description<a class="aui-toc-hash" href="#detailed-description" id="detailed-description" style="color: var(--fragment-comment) !important">#</a></h2>
<p><b aui-src="aui.uitests/tests/UIDataBindingTest.cpp#L32"></b></p>
<dl class="section warning"><dt>Warning</dt><dd>This API is experimental. Experimental APIs are likely to contain bugs, might be changed or removed in the future. </dd></dl>
<dl class="section user"><dt></dt><dd>AUI property system, a compiler-agnostic alternative to __property or [property]. Based on signal-slot system for platform-independent C++ development. Unlike Qt, AUI's properties don't involve external tools (like <code>moc</code>). They are written in pure C++.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This page is about presenting individual values. For lists, see <a class="el" href="classAForEachUI.html">AForEachUI</a>.</dd></dl>
<p>AUI property system is relatively complex, as it involves a lot of features in a single place:</p><ol type="1">
<li>thread safe</li>
<li>many-to-many relationships between objects</li>
<li>optional data modification when passing values between objects (like STL projections)</li>
<li>emitter can be either signal or property</li>
<li>slot can be either lambda, method or property</li>
<li>for the latter case, system must set up backward connection as well (including projection support)</li>
<li>again, for the latter case, there's an option to make property-to-slot connection, where the "slot" is property's assignment operation</li>
<li>2 syntax variants: procedural (straightforward) and declarative</li>
<li>three property variants: simple field (<a class="el" href="structAProperty.html" title="Basic easy-to-use property implementation containing T.">AProperty</a>), custom getter/setter (<a class="el" href="structAPropertyDef.html" title="Property implementation to use with custom getter/setter.">APropertyDef</a>) and custom evaluation (<a class="el" href="structAPropertyPrecomputed.html" title="Readonly property that holds a value computed by an expression.">APropertyPrecomputed</a>)</li>
<li>some properties can be readonly</li>
<li>propagating strong types' traits on views</li>
</ol>
<p>Learning curve is relatively flat, so be sure to <a href="https://github.com/aui-framework/aui/issues">ask questions and open issues</a> on our GitHub page.</p>
<p>Main difference between basic value lying somewhere inside your class and a property is that the latter explicitly ties getter, setter and a signal reporting value changes. Property acts almost transparently, as if there's no extra wrapper around your data. This allows to work with properties in the same way as with their underlying values. You can read the intermediate value of a property and subscribe to its changes via a single <code>connect</code> call. Also, when connecting property to property, it is possible to make them observe changes of each other bia <code>biConnect</code> call: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>User {</div>
<div class="line">    <a class="code hl_class" href="structAProperty.html">AProperty&lt;AString&gt;</a> name;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> user = <a class="code hl_function" href="structaui_1_1ptr.html#a9696eab52bd0745688055a301d9ef776">aui::ptr::manage</a>(<span class="keyword">new</span> User { .name = <span class="stringliteral">"Robert"</span> });</div>
<div class="line"><span class="keyword">auto</span> tf = _new&lt;ATextField&gt;();</div>
<div class="line"><a class="code hl_function" href="#ga1eb0abe12d4d0c4db737cc63582791cd">AObject::biConnect</a>(user-&gt;name, tf-&gt;text());</div>
<div class="line"><span class="keyword">auto</span> window = _new&lt;AWindow&gt;();</div>
<div class="line">window-&gt;setContents(Centered { tf });</div>
<div class="line">window-&gt;show();</div>
<div class="ttc" id="agroup__property__system_html_ga1eb0abe12d4d0c4db737cc63582791cd"><div class="ttname"><a href="#ga1eb0abe12d4d0c4db737cc63582791cd">AObject::biConnect</a></div><div class="ttdeci">static void biConnect(PropertySource &amp;&amp;propertySource, PropertyDestination &amp;&amp;propertyDestination)</div><div class="ttdoc">Connects source property to the destination property and opposite (bidirectionally).</div><div class="ttdef"><b>Definition</b> AObject.h:156</div></div>
<div class="ttc" id="astructAProperty_html"><div class="ttname"><a href="structAProperty.html">AProperty</a></div><div class="ttdoc">Basic easy-to-use property implementation containing T.</div><div class="ttdef"><b>Definition</b> AProperty.h:30</div></div>
<div class="ttc" id="astructaui_1_1ptr_html_a9696eab52bd0745688055a301d9ef776"><div class="ttname"><a href="structaui_1_1ptr.html#a9696eab52bd0745688055a301d9ef776">aui::ptr::manage</a></div><div class="ttdeci">static _&lt; T &gt; manage(T *raw)</div><div class="ttdoc">Delegates memory management of the raw pointer T* raw to the shared pointer, which is returned.</div><div class="ttdef"><b>Definition</b> SharedPtrTypes.h:424</div></div>
</div><!-- fragment --><p>Or simpler: </p><div class="fragment"><div class="line"><span class="comment">// ...</span></div>
<div class="line">window-&gt;setContents(Centered {</div>
<div class="line">  tf &amp;&amp; user-&gt;name,</div>
<div class="line">});</div>
<div class="line"><span class="comment">// ...</span></div>
</div><!-- fragment --><p>The code above generates a window with a text field: <img alt="" class="inline" src="UIDataBindingTest.TextField1_1.png" title="text field"/> </p>
<p>A single call of <code>biConnect</code>:</p>
<ul>
<li>Prefills text field with the current <code>user-&gt;name</code> value (pre fire): <div class="fragment"><div class="line">EXPECT_EQ(tf-&gt;text(), <span class="stringliteral">"Robert"</span>);</div>
</div><!-- fragment --></li>
<li>Connects <code>user-&gt;named.changed</code> to <code>tf</code> to notify the text field about changes of <code>user-&gt;name</code>: <div class="fragment"><div class="line">user-&gt;name = <span class="stringliteral">"Angela"</span>;           <span class="comment">// changing user-&gt;name programmatically...</span></div>
<div class="line">EXPECT_EQ(tf-&gt;text(), <span class="stringliteral">"Angela"</span>); <span class="comment">// ...should reflect on the text field</span></div>
</div><!-- fragment --></li>
</ul>
<p><img alt="" class="inline" src="UIDataBindingTest.TextField1_2.png" title="text field"/> </p>
<ul>
<li>Connects <code>tf-&gt;text().changed</code> to notify the <code>user-&gt;name</code> property about changes in text field (i.e., if the user typed another value to the text field): <img alt="" class="inline" src="UIDataBindingTest.TextField1_3.png" title="text field"/> </li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// user typed "Snezhana", now let's check the value in user-&gt;name:</span></div>
<div class="line">EXPECT_EQ(user-&gt;name, <span class="stringliteral">"Snezhana"</span>);</div>
</div><!-- fragment --><p>This is basic example of setting up property-to-property connection.</p>
<h1>
Declaring Properties<a class="aui-toc-hash" href="#declaring-properties" id="declaring-properties" style="color: var(--fragment-comment) !important">#</a></h1>
<p><b aui-src="aui.uitests/tests/UIDataBindingTest.cpp#L131"></b> There are several ways to define a property in AUI:</p><ul>
<li><a class="el" href="structAProperty.html" title="Basic easy-to-use property implementation containing T.">AProperty</a> - basic wrapper property type for data models</li>
<li><a class="el" href="structAPropertyDef.html" title="Property implementation to use with custom getter/setter.">APropertyDef</a> - property-compliant view type to tie custom getter, setter and signal together</li>
<li><a class="el" href="structAPropertyPrecomputed.html" title="Readonly property that holds a value computed by an expression.">APropertyPrecomputed</a> - readonly property whose value is determined by a callable that references other properties</li>
</ul>
<p>Please check their respective documentation pages for an additional information.</p>
<h1>
UI data binding with let<a class="aui-toc-hash" href="#ui-data-binding-with-let" id="ui-data-binding-with-let" style="color: var(--fragment-comment) !important">#</a></h1>
<p><b aui-src="aui.uitests/tests/UIDataBindingTest.cpp#L139"></b> </p><dl class="section note"><dt>Note</dt><dd>This is a comprehensive, straightforward way of setting up a connection. We are demonstrating it here so you can get deeper understanding on how connections are made and what does declarative way do under the hood. This way may be used in favour of declarative way if the latter not work for you. For declarative way, go to <a class="el" href="#UI_declarative_data_binding">UI declarative data binding</a>.</dd></dl>
<p>This approach allows more control over the binding process by using <code><a class="el" href="group__signal__slot.html#ga4da6280feaeb063ce8e5b8a069755d6d" title="Connects signal to the slot of the specified object.">AObject::connect</a></code>/<code><a class="el" href="#ga1eb0abe12d4d0c4db737cc63582791cd" title="Connects source property to the destination property and opposite (bidirectionally).">AObject::biConnect</a></code> which is a procedural way of setting up connections. As a downside, it requires "let" syntax clause which may seem as overkill for such a simple operation.</p>
<h2>
Label via let<a class="aui-toc-hash" href="#UIDataBindingTest_Label_via_let" id="UIDataBindingTest_Label_via_let" style="color: var(--fragment-comment) !important">#</a></h2>
<p><b aui-src="aui.uitests/tests/UIDataBindingTest.cpp#L149"></b> Use <code>let</code> expression to connect the model's username property to the label's <a class="el" href="classAAbstractLabel.html#a22750596fa02b042ae73c6fcabad750d">text()</a> property. </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span>declarative;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>User {</div>
<div class="line">    <a class="code hl_class" href="structAProperty.html">AProperty&lt;AString&gt;</a> name;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> user = <a class="code hl_function" href="structaui_1_1ptr.html#a9696eab52bd0745688055a301d9ef776">aui::ptr::manage</a>(<span class="keyword">new</span> User { .name = <span class="stringliteral">"Roza"</span> });</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyWindow: <span class="keyword">public</span> <a class="code hl_class" href="classAWindow.html">AWindow</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MyWindow(<span class="keyword">const</span> _&lt;User&gt;&amp; user) {</div>
<div class="line">        <a class="code hl_function" href="classAViewContainer.html#ab7bcd4a4bc08fc11c9bc1a9ff036f5e4">setContents</a>(Centered {</div>
<div class="line">            _new&lt;ALabel&gt;() <a class="code hl_define" href="group__useful__macros.html#ga045dd54932944d8830380f4596d64446">let</a> {</div>
<div class="line">              <span class="comment">// Data goes from left to right:</span></div>
<div class="line">              <span class="comment">// current value (pre fire) or changed event</span></div>
<div class="line">              <span class="comment">// goes to assignment operation of it-&gt;text()</span></div>
<div class="line">              <a class="code hl_function" href="group__signal__slot.html#ga4da6280feaeb063ce8e5b8a069755d6d">AObject::connect</a>(user-&gt;name, it-&gt;text());</div>
<div class="line">              <span class="comment">//                -&gt;  -&gt;  -&gt;  -&gt;  -&gt;</span></div>
<div class="line">              <span class="comment">// in other words, this connection is essentially the</span></div>
<div class="line">              <span class="comment">// same as</span></div>
<div class="line">              <span class="comment">// AObject::connect(user-&gt;name, slot(it)::setText);</span></div>
<div class="line">              <span class="comment">//</span></div>
<div class="line">              <span class="comment">// if you want user-&gt;name to be aware or it-&gt;text()</span></div>
<div class="line">              <span class="comment">// changes (i.e., if it were an editable view</span></div>
<div class="line">              <span class="comment">// like ATextField) use AObject::biConnect instead</span></div>
<div class="line">              <span class="comment">// (see "Bidirectional connection" sample).</span></div>
<div class="line">            },</div>
<div class="line">        });</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line">_new&lt;MyWindow&gt;(user)-&gt;<a class="code hl_function" href="classAWindow.html#af7360ab4bb102de6cbdf066e9ab8348b">show</a>();</div>
<div class="ttc" id="aclassAViewContainer_html_ab7bcd4a4bc08fc11c9bc1a9ff036f5e4"><div class="ttname"><a href="classAViewContainer.html#ab7bcd4a4bc08fc11c9bc1a9ff036f5e4">AViewContainer::setContents</a></div><div class="ttdeci">void setContents(const _&lt; AViewContainer &gt; &amp;container)</div><div class="ttdoc">Moves (like via std::move) all children and layout of the specified container to this container.</div></div>
<div class="ttc" id="aclassAWindow_html"><div class="ttname"><a href="classAWindow.html">AWindow</a></div><div class="ttdoc">Represents a window in the underlying windowing system.</div><div class="ttdef"><b>Definition</b> AWindow.h:45</div></div>
<div class="ttc" id="aclassAWindow_html_af7360ab4bb102de6cbdf066e9ab8348b"><div class="ttname"><a href="classAWindow.html#af7360ab4bb102de6cbdf066e9ab8348b">AWindow::show</a></div><div class="ttdeci">void show()</div></div>
<div class="ttc" id="agroup__signal__slot_html_ga4da6280feaeb063ce8e5b8a069755d6d"><div class="ttname"><a href="group__signal__slot.html#ga4da6280feaeb063ce8e5b8a069755d6d">AObject::connect</a></div><div class="ttdeci">static decltype(auto) connect(const Signal &amp;signal, Object *object, Function &amp;&amp;function)</div><div class="ttdoc">Connects signal to the slot of the specified object.</div><div class="ttdef"><b>Definition</b> AObject.h:86</div></div>
<div class="ttc" id="agroup__useful__macros_html_ga045dd54932944d8830380f4596d64446"><div class="ttname"><a href="group__useful__macros.html#ga045dd54932944d8830380f4596d64446">let</a></div><div class="ttdeci">#define let</div><div class="ttdoc">Performs multiple operations on a single object without repeating its name (in place) This function c...</div><div class="ttdef"><b>Definition</b> kAUI.h:262</div></div>
</div><!-- fragment --><p>This gives the following result: <img alt="" class="inline" src="UIDataBindingTest.Label_via_declarative_1.png"/> </p>
<p>Note that label already displays the value stored in User.</p>
<p>Let's change the name: </p><div class="fragment"><div class="line">user-&gt;name = <span class="stringliteral">"Vasil"</span>;</div>
</div><!-- fragment --><div class="image">
<img alt="" src="UIDataBindingTest.Label_via_declarative_2.png"/>
</div>
<p>By simply performing assignment on <code>user</code> we changed <a class="el" href="classALabel.html" title="Represents a simple single-line text display view.">ALabel</a> display text. Magic, huh?</p>
<h2>
Label via let projection<a class="aui-toc-hash" href="#UIDataBindingTest_Label_via_let_projection" id="UIDataBindingTest_Label_via_let_projection" style="color: var(--fragment-comment) !important">#</a></h2>
<p><b aui-src="aui.uitests/tests/UIDataBindingTest.cpp#L210"></b> It's fairly easy to define a projection because one-sided connection requires exactly one projection, obviously. </p><div class="fragment"><div class="line">_new&lt;ALabel&gt;() <a class="code hl_define" href="group__useful__macros.html#ga045dd54932944d8830380f4596d64446">let</a> {</div>
<div class="line">    <span class="comment">// Data goes from left to right:</span></div>
<div class="line">    <span class="comment">// current value (pre fire) or changed event</span></div>
<div class="line">    <span class="comment">// goes through projection (&amp;AString::uppercase) first</span></div>
<div class="line">    <span class="comment">// then it goes to assignment operation of it-&gt;text()</span></div>
<div class="line">    <span class="comment">// property.</span></div>
<div class="line">    <a class="code hl_function" href="group__signal__slot.html#ga4da6280feaeb063ce8e5b8a069755d6d">AObject::connect</a>(user-&gt;name.readProjected(&amp;AString::uppercase), it-&gt;text());</div>
<div class="line">    <span class="comment">//                -&gt;  -&gt;  -&gt;  -&gt;  -&gt;  -&gt;  -&gt;  -&gt;  -&gt;  -&gt;  -&gt;  -&gt;</span></div>
<div class="line">    <span class="comment">// in other words, this connection is essentially the same as</span></div>
<div class="line">    <span class="comment">// AObject::connect(user-&gt;name.projected(&amp;AString::uppercase), slot(it)::setText);</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// if view's property gets changed (i.e., by user or by occasional</span></div>
<div class="line">    <span class="comment">// ALabel::setText), these changes DO NOT reflect on model</span></div>
<div class="line">    <span class="comment">// as we requested connect() here instead of biConnect().</span></div>
<div class="line">},</div>
</div><!-- fragment --><p>This gives the following result: <img alt="" class="inline" src="UIDataBindingTest.Label_via_declarative_projection_1.png"/> </p>
<p>Note that the label already displays the <b>projected</b> value stored in User.</p>
<p>Let's change the name: </p><div class="fragment"><div class="line">user-&gt;name = <span class="stringliteral">"Vasil"</span>;</div>
</div><!-- fragment --><div class="image">
<img alt="" src="UIDataBindingTest.Label_via_declarative_projection_2.png"/>
</div>
<p>This way, we've set up data binding with projection.</p>
<h2>
Bidirectional connection<a class="aui-toc-hash" href="#UIDataBindingTest_Bidirectional_connection" id="UIDataBindingTest_Bidirectional_connection" style="color: var(--fragment-comment) !important">#</a></h2>
<p><b aui-src="aui.uitests/tests/UIDataBindingTest.cpp#L267"></b> In previous examples, we've used <code><a class="el" href="group__signal__slot.html#ga4da6280feaeb063ce8e5b8a069755d6d" title="Connects signal to the slot of the specified object.">AObject::connect</a></code> to make one directional (one sided) connection. This is perfectly enough for <a class="el" href="classALabel.html" title="Represents a simple single-line text display view.">ALabel</a> because it cannot be changed by user.</p>
<p>In some cases, you might want to use property-to-property as it's bidirectional. It's used for populating view from model and obtaining data from view back to the model.</p>
<p>For this example, let's use <a class="el" href="classATextField.html" title="Editable field with text to receive a text input from the user.">ATextField</a> instead of <a class="el" href="classALabel.html" title="Represents a simple single-line text display view.">ALabel</a> as it's an editable view. In this case, we'd want to use <code><a class="el" href="#ga1eb0abe12d4d0c4db737cc63582791cd" title="Connects source property to the destination property and opposite (bidirectionally).">AObject::biConnect</a></code> because we do want <code>user-&gt;name</code> to be aware of changes of the view. </p><div class="fragment"><div class="line">_new&lt;ATextField&gt;() <a class="code hl_define" href="group__useful__macros.html#ga045dd54932944d8830380f4596d64446">let</a> {</div>
<div class="line">  <span class="comment">// Data goes from left to right in the first place</span></div>
<div class="line">  <span class="comment">// (i.e., user-&gt;name current value overrides it-&gt;text())</span></div>
<div class="line">  <span class="comment">// if view's property gets changed (i.e., by user),</span></div>
<div class="line">  <span class="comment">// these changes reflect on model</span></div>
<div class="line">  <span class="comment">// as we requested biConnect here</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">//                -&gt; value + changes -&gt;</span></div>
<div class="line">  <a class="code hl_function" href="#ga1eb0abe12d4d0c4db737cc63582791cd">AObject::biConnect</a>(user-&gt;name, it-&gt;text());</div>
<div class="line">  <span class="comment">//                &lt;-  changes only   &lt;-</span></div>
<div class="line">},</div>
</div><!-- fragment --><p>This gives the following result: <img alt="" class="inline" src="UIDataBindingTest.Declarative_bidirectional_connection_1.png"/> </p>
<p>Let's change the name programmatically: </p><div class="fragment"><div class="line">user-&gt;name = <span class="stringliteral">"Vasil"</span>;</div>
</div><!-- fragment --><p><a class="el" href="classATextField.html" title="Editable field with text to receive a text input from the user.">ATextField</a> will respond: <img alt="" class="inline" src="UIDataBindingTest.Declarative_bidirectional_connection_2.png"/> </p>
<p>If the user changes the value from UI, these changes will reflect on <code>user-&gt;model</code> as well: <img alt="" class="inline" src="UIDataBindingTest.Declarative_bidirectional_connection_3.png"/> </p>
<div class="fragment"><div class="line">EXPECT_EQ(user-&gt;name, <span class="stringliteral">"Changed from UI"</span>);</div>
</div><!-- fragment --><p>This way we've set up bidirectional projection via <code><a class="el" href="#ga1eb0abe12d4d0c4db737cc63582791cd" title="Connects source property to the destination property and opposite (bidirectionally).">AObject::biConnect</a></code> which makes <code>user-&gt;name</code> aware of UI changes.</p>
<h2>
Bidirectional projection<a class="aui-toc-hash" href="#UIDataBindingTest_Bidirectional_projection" id="UIDataBindingTest_Bidirectional_projection" style="color: var(--fragment-comment) !important">#</a></h2>
<p><b aui-src="aui.uitests/tests/UIDataBindingTest.cpp#L347"></b> Bidirectional connection updates values in both directions, hence it requires the projection to work in both sides as well.</p>
<p>It is the case for <a class="el" href="classADropdownList.html" title="A button with dropdown list.">ADropdownList</a> with enums. <a class="el" href="classADropdownList.html" title="A button with dropdown list.">ADropdownList</a> works with string list model and indices. It does not know anything about underlying values.</p>
<p>For example, define enum with <a class="el" href="group__useful__macros.html#ga339936ba5146bdad18838e527f34e9df">AUI_ENUM_VALUES</a> and model:</p>
<div class="fragment"><div class="line"><span class="keyword">enum class</span> Gender {</div>
<div class="line">    MALE,</div>
<div class="line">    FEMALE,</div>
<div class="line">    OTHER,</div>
<div class="line">};</div>
<div class="line"><a class="code hl_define" href="group__useful__macros.html#ga339936ba5146bdad18838e527f34e9df">AUI_ENUM_VALUES</a>(Gender,</div>
<div class="line">                Gender::MALE,</div>
<div class="line">                Gender::FEMALE,</div>
<div class="line">                Gender::OTHER)</div>
<div class="ttc" id="agroup__useful__macros_html_ga339936ba5146bdad18838e527f34e9df"><div class="ttname"><a href="group__useful__macros.html#ga339936ba5146bdad18838e527f34e9df">AUI_ENUM_VALUES</a></div><div class="ttdeci">#define AUI_ENUM_VALUES(enum_t,...)</div><div class="ttdoc">Defines all enum values for AEnumerate.</div><div class="ttdef"><b>Definition</b> AEnumerate.h:208</div></div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="keyword">struct </span>User {</div>
<div class="line">    <a class="code hl_class" href="structAProperty.html">AProperty&lt;Gender&gt;</a> gender;</div>
<div class="line">    <span class="comment">// we've omitted other fields for sake of simplicity</span></div>
<div class="line">};</div>
</div><!-- fragment --><p>Now, let's get a mapping for our <code>Gender</code> enum: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> GENDERS = <a class="code hl_variable" href="group__core.html#ga177fb99c6b6cf725dc64202f891678cf">aui::enumerate::ALL_VALUES&lt;Gender&gt;</a>;</div>
<div class="ttc" id="agroup__core_html_ga177fb99c6b6cf725dc64202f891678cf"><div class="ttname"><a href="group__core.html#ga177fb99c6b6cf725dc64202f891678cf">aui::enumerate::ALL_VALUES</a></div><div class="ttdeci">constexpr auto ALL_VALUES</div><div class="ttdoc">constexpr std::array of all possible enum values is the order they've been passed to AUI_ENUM_VALUES.</div><div class="ttdef"><b>Definition</b> AEnumerate.h:176</div></div>
</div><!-- fragment --><p>The compile-time constant above is equivalent to: </p><div class="fragment"><div class="line"><span class="comment">/* pseudocode */</span></div>
<div class="line">GENDERS = std::array { Gender::MALE, Gender::FEMALE, GENDER::OTHER };</div>
</div><!-- fragment --><p>We just using <code><a class="el" href="group__core.html#ga177fb99c6b6cf725dc64202f891678cf" title="constexpr std::array of all possible enum values is the order they've been passed to AUI_ENUM_VALUES.">aui::enumerate::ALL_VALUES</a></code> because it was provided conveniently by <code>AUI_ENUM_VALUES</code> for us.</p>
<p>It's not hard to guess that we'll use indices of this array to uniquely identify <code>Gender</code> associated with this index: </p><div class="fragment"><div class="line"><span class="comment">/* pseudocode */</span></div>
<div class="line">GENDERS[0]; <span class="comment">// -&gt; MALE</span></div>
<div class="line">GENDERS[1]; <span class="comment">// -&gt; FEMALE</span></div>
<div class="line">GENDERS[2]; <span class="comment">// -&gt; OTHER</span></div>
</div><!-- fragment --><p>To perform opposite operation (i.e., <code>Gender</code> to int), we can use <code><a class="el" href="group__core.html#ga4cfb55637d96cbb11c9c00bcb6a7998d" title="Finds the index of the first occurrence of the value.">aui::indexOf</a></code>: </p><div class="fragment"><div class="line"><span class="comment">/* pseudocode */</span></div>
<div class="line"><a class="code hl_function" href="group__core.html#ga4cfb55637d96cbb11c9c00bcb6a7998d">aui::indexOf</a>(GENDERS, Gender::MALE);   <span class="comment">// -&gt; 0</span></div>
<div class="line"><a class="code hl_function" href="group__core.html#ga4cfb55637d96cbb11c9c00bcb6a7998d">aui::indexOf</a>(GENDERS, Gender::FEMALE); <span class="comment">// -&gt; 1</span></div>
<div class="line"><a class="code hl_function" href="group__core.html#ga4cfb55637d96cbb11c9c00bcb6a7998d">aui::indexOf</a>(GENDERS, Gender::OTHER);  <span class="comment">// -&gt; 2</span></div>
<div class="ttc" id="agroup__core_html_ga4cfb55637d96cbb11c9c00bcb6a7998d"><div class="ttname"><a href="group__core.html#ga4cfb55637d96cbb11c9c00bcb6a7998d">aui::indexOf</a></div><div class="ttdeci">AOptional&lt; size_t &gt; indexOf(const Container &amp;c, const typename Container::const_reference value) noexcept</div><div class="ttdoc">Finds the index of the first occurrence of the value.</div><div class="ttdef"><b>Definition</b> containers.h:227</div></div>
</div><!-- fragment --><p>To bring these conversions together, let's use overloaded lambda: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> GENDER_INDEX_PROJECTION = <a class="code hl_struct" href="structaui_1_1lambda__overloaded.html">aui::lambda_overloaded</a> {</div>
<div class="line">    [](Gender g) -&gt; <span class="keywordtype">int</span> { <span class="keywordflow">return</span> <a class="code hl_function" href="group__core.html#ga4cfb55637d96cbb11c9c00bcb6a7998d">aui::indexOf</a>(GENDERS, g).valueOr(0); },</div>
<div class="line">    [](<span class="keywordtype">int</span> i) -&gt; Gender { <span class="keywordflow">return</span> GENDERS[i]; },</div>
<div class="line">};</div>
<div class="ttc" id="astructaui_1_1lambda__overloaded_html"><div class="ttname"><a href="structaui_1_1lambda__overloaded.html">aui::lambda_overloaded</a></div><div class="ttdef"><b>Definition</b> callables.h:36</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>It's convenient to use lambda trailing return type syntax (i.e., <code>... -&gt; int</code>, <code>... -&gt; Gender</code>) to make it obvious what do transformations do and how one type is transformed to another.</dd></dl>
<p>The function-like object above detects the direction of transformation and performs as follows: </p><div class="fragment"><div class="line">GENDER_INDEX_PROJECTION(0); <span class="comment">// -&gt; MALE</span></div>
<div class="line">GENDER_INDEX_PROJECTION(Gender::MALE); <span class="comment">// -&gt; 0</span></div>
</div><!-- fragment --><p>It is all what we need to set up bidirectional transformations. Inside AUI_ENTRY: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> user = <a class="code hl_function" href="structaui_1_1ptr.html#a9696eab52bd0745688055a301d9ef776">aui::ptr::manage</a>(<span class="keyword">new</span> User { .gender = Gender::MALE });</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyWindow: <span class="keyword">public</span> <a class="code hl_class" href="classAWindow.html">AWindow</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MyWindow(<span class="keyword">const</span> <a class="code hl_class" href="class__.html">_&lt;User&gt;</a>&amp; user) {</div>
<div class="line">        <span class="comment">// generate a string list model for genders from GENDERS array defined earlier</span></div>
<div class="line">        <span class="keyword">auto</span> gendersStr = <a class="code hl_function" href="classAListModel.html#a1e533fa4d29b2861c76fcd00c297c5fb">AListModel&lt;AString&gt;::fromVector</a>(</div>
<div class="line">            GENDERS</div>
<div class="line">            | ranges::views::transform(<a class="code hl_function" href="classAEnumerate.html#afa68fcde8a649cfb3240410a4d995428">AEnumerate&lt;Gender&gt;::toName</a>)</div>
<div class="line">            | ranges::to_vector);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// equivalent:</span></div>
<div class="line">        <span class="comment">// gendersStr = { "MALE", "FEMALE", "OTHER" }</span></div>
<div class="line">        <span class="comment">// you can customize the displayed strings by playing with</span></div>
<div class="line">        <span class="comment">// ranges::views::transform argument.</span></div>
<div class="line"> </div>
<div class="line">        <a class="code hl_function" href="classAViewContainer.html#ab7bcd4a4bc08fc11c9bc1a9ff036f5e4">setContents</a>(Centered {</div>
<div class="line">          _new&lt;ADropdownList&gt;(gendersStr) <a class="code hl_define" href="group__useful__macros.html#ga045dd54932944d8830380f4596d64446">let</a> {</div>
<div class="line">              <span class="comment">// AObject::connect(user-&gt;gender, it-&gt;selectionId());</span></div>
<div class="line">              <span class="comment">//</span></div>
<div class="line">              <span class="comment">// The code above would break, because Gender and int</span></div>
<div class="line">              <span class="comment">// (selectionId() type) are incompatible.</span></div>
<div class="line">              <span class="comment">//</span></div>
<div class="line">              <span class="comment">// Instead, define bidirectional projection:</span></div>
<div class="line">               <a class="code hl_function" href="#ga1eb0abe12d4d0c4db737cc63582791cd">AObject::biConnect</a>(</div>
<div class="line">                   user-&gt;gender.biProjected(GENDER_INDEX_PROJECTION),</div>
<div class="line">                   it-&gt;selectionId());</div>
<div class="line">              },</div>
<div class="line">        });</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line">_new&lt;MyWindow&gt;(user)-&gt;show();</div>
<div class="ttc" id="aclassAEnumerate_html_afa68fcde8a649cfb3240410a4d995428"><div class="ttname"><a href="classAEnumerate.html#afa68fcde8a649cfb3240410a4d995428">AEnumerate::toName</a></div><div class="ttdeci">static const AString &amp; toName(enum_t value)</div><div class="ttdoc">Map runtime enum value to name. Throws an exception if no such value.</div><div class="ttdef"><b>Definition</b> AEnumerate.h:134</div></div>
<div class="ttc" id="aclassAListModel_html_a1e533fa4d29b2861c76fcd00c297c5fb"><div class="ttname"><a href="classAListModel.html#a1e533fa4d29b2861c76fcd00c297c5fb">AListModel::fromVector</a></div><div class="ttdeci">static _&lt; AListModel&lt; StoredType &gt; &gt; fromVector(AVector&lt; V &gt; t)</div><div class="ttdef"><b>Definition</b> AListModel.h:268</div></div>
<div class="ttc" id="aclass___html"><div class="ttname"><a href="class__.html">_</a></div><div class="ttdoc">An std::weak_ptr with AUI extensions.</div><div class="ttdef"><b>Definition</b> SharedPtrTypes.h:179</div></div>
</div><!-- fragment --><div class="image">
<img alt="" src="UIDataBindingTest.Declarative_bidirectional_projection_1.png"/>
</div>
<ul>
<li>If we try to change <code>user-&gt;gender</code> programmatically, <a class="el" href="classADropdownList.html" title="A button with dropdown list.">ADropdownList</a> will respond: <div class="fragment"><div class="line">user-&gt;gender = Gender::FEMALE;</div>
<div class="line">EXPECT_EQ(dropdownList-&gt;getSelectedId(), 1); <span class="comment">// second option</span></div>
</div><!-- fragment --></li>
</ul>
<div class="image">
<img alt="" src="UIDataBindingTest.Declarative_bidirectional_projection_2.png"/>
</div>
<ul>
<li>If the user changes the value of <a class="el" href="classADropdownList.html" title="A button with dropdown list.">ADropdownList</a>, it reflects on the model as well: <div class="fragment"><div class="line">EXPECT_EQ(user-&gt;gender, Gender::OTHER);</div>
</div><!-- fragment --></li>
</ul>
<div class="image">
<img alt="" src="UIDataBindingTest.Declarative_bidirectional_projection_3.png"/>
</div>
<h1>
UI declarative data binding<a class="aui-toc-hash" href="#UI_declarative_data_binding" id="UI_declarative_data_binding" style="color: var(--fragment-comment) !important">#</a></h1>
<p><b aui-src="aui.uitests/tests/UIDataBindingTest.cpp#L479"></b> As said earlier, <code>let</code> syntax is a little bit clunky and requires extra boilerplate code to set up.</p>
<p>Here's where declarative syntax comes into play. The logic behind the syntax is the same as in <code><a class="el" href="group__signal__slot.html#ga4da6280feaeb063ce8e5b8a069755d6d" title="Connects signal to the slot of the specified object.">AObject::connect</a></code>/<code><a class="el" href="#ga1eb0abe12d4d0c4db737cc63582791cd" title="Connects source property to the destination property and opposite (bidirectionally).">AObject::biConnect</a></code> (for ease of replacement/understanding).</p>
<p>Declarative syntax uses <code>&amp;</code> and <code>&amp;&amp;</code> operators to set up connections. These were chosen intentionally: <code>&amp;&amp;</code> resembles chain, so we "chaining view and property up".</p>
<ul>
<li><code>&amp;</code> sets up one-directional connection (<code><a class="el" href="group__signal__slot.html#ga4da6280feaeb063ce8e5b8a069755d6d" title="Connects signal to the slot of the specified object.">AObject::connect</a></code>).</li>
<li><code>&amp;&amp;</code> sets up bidirectional connection (<code><a class="el" href="#ga1eb0abe12d4d0c4db737cc63582791cd" title="Connects source property to the destination property and opposite (bidirectionally).">AObject::biConnect</a></code>).</li>
</ul>
<p>Also, <code>&gt;</code> operator (resembles arrow) is used to specify the destination slot.</p>
<p>The example below is essentially the same as <a class="el" href="#UIDataBindingTest_Label_via_let">Label via let</a> but uses declarative connection set up syntax.</p>
<h2>
Label via declarative<a class="aui-toc-hash" href="#UIDataBindingTest_Label_via_declarative" id="UIDataBindingTest_Label_via_declarative" style="color: var(--fragment-comment) !important">#</a></h2>
<p><b aui-src="aui.uitests/tests/UIDataBindingTest.cpp#L494"></b> Use <code>&amp;</code> and <code>&gt;</code> expression to connect the model's username property to the label's <a class="el" href="classAAbstractLabel.html#a22750596fa02b042ae73c6fcabad750d">text</a> property. </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span>declarative;</div>
<div class="line"><span class="keyword">struct </span>User {</div>
<div class="line">    <a class="code hl_class" href="structAProperty.html">AProperty&lt;AString&gt;</a> name;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> user = <a class="code hl_function" href="structaui_1_1ptr.html#a9696eab52bd0745688055a301d9ef776">aui::ptr::manage</a>(<span class="keyword">new</span> User { .name = <span class="stringliteral">"Roza"</span> });</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyWindow: <span class="keyword">public</span> <a class="code hl_class" href="classAWindow.html">AWindow</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MyWindow(<span class="keyword">const</span> _&lt;User&gt;&amp; user) {</div>
<div class="line">        <a class="code hl_function" href="classAViewContainer.html#ab7bcd4a4bc08fc11c9bc1a9ff036f5e4">setContents</a>(Centered {</div>
<div class="line">          _new&lt;ALabel&gt;() &amp; user-&gt;name &gt; &amp;<a class="code hl_function" href="classAAbstractLabel.html#a22750596fa02b042ae73c6fcabad750d">ALabel::text</a></div>
<div class="line">        });</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"><span class="keyword">auto</span> window = _new&lt;MyWindow&gt;(user);</div>
<div class="line">window-&gt;show();</div>
<div class="ttc" id="aclassAAbstractLabel_html_a22750596fa02b042ae73c6fcabad750d"><div class="ttname"><a href="classAAbstractLabel.html#a22750596fa02b042ae73c6fcabad750d">AAbstractLabel::text</a></div><div class="ttdeci">auto text() const</div><div class="ttdoc">Label's text property.</div><div class="ttdef"><b>Definition</b> AAbstractLabel.h:37</div></div>
</div><!-- fragment --><p><img alt="" class="inline" src="UIDataBindingTest.Label_via_declarative_1.png"/> </p>
<p>Note that the label already displays the value stored in User.</p>
<p>Let's change the name: </p><div class="fragment"><div class="line">user-&gt;name = <span class="stringliteral">"Vasil"</span>;</div>
</div><!-- fragment --><p><img alt="" class="inline" src="UIDataBindingTest.Label_via_declarative_2.png"/> </p>
<p>In this example, we've achieved the same intuitive behaviour of data binding of <code>user-&gt;name</code> (like in <a class="el" href="#UIDataBindingTest_Label_via_let">Label via let</a> example) but using declarative syntax. The logic behind <code>&amp;</code> is almost the same as with <code>let</code> and <code><a class="el" href="group__signal__slot.html#ga4da6280feaeb063ce8e5b8a069755d6d" title="Connects signal to the slot of the specified object.">AObject::connect</a></code> so projection use cases can be adapted in a similar manner.</p>
<h2>
ADataBindingDefault for omitting view property<a class="aui-toc-hash" href="#UIDataBindingTest_ADataBindingDefault_for_omitting_view_property" id="UIDataBindingTest_ADataBindingDefault_for_omitting_view_property" style="color: var(--fragment-comment) !important">#</a></h2>
<p><b aui-src="aui.uitests/tests/UIDataBindingTest.cpp#L551"></b> In previous example we have explicitly specified <a class="el" href="classALabel.html" title="Represents a simple single-line text display view.">ALabel</a>'s property to connect with.</p>
<p>One of notable features of declarative way (in comparison to procedural <code>let</code> way) is that we can omit the view's property to connect with if such <code><a class="el" href="structADataBindingDefault.html" title="Defines how View handles properties of FieldType type.">ADataBindingDefault</a></code> specialization exist for the target view and the property type. Some views have already predefined such specialization for their underlying types. For instance, <a class="el" href="classALabel.html" title="Represents a simple single-line text display view.">ALabel</a> has such specialization:</p>
<div class="fragment"><div class="line"><span class="comment">/* PREDEFINED! You don't need to define it! This listing is an example */</span></div>
<div class="line"><span class="keyword">template</span>&lt;&gt;</div>
<div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structADataBindingDefault.html">ADataBindingDefault</a>&lt;<a class="code hl_class" href="classALabel.html">ALabel</a>, <a class="code hl_class" href="classAString.html">AString</a>&gt; {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">auto</span> <a class="code hl_function" href="structADataBindingDefault.html#a8b84a1211f21be11840c0f38d5d69c2a">property</a>(<span class="keyword">const</span> <a class="code hl_class" href="class__.html">_&lt;ALabel&gt;</a>&amp; view) { <span class="keywordflow">return</span> view-&gt;text(); }</div>
<div class="line">};</div>
<div class="ttc" id="aclassALabel_html"><div class="ttname"><a href="classALabel.html">ALabel</a></div><div class="ttdoc">Represents a simple single-line text display view.</div><div class="ttdef"><b>Definition</b> ALabel.h:23</div></div>
<div class="ttc" id="aclassAString_html"><div class="ttname"><a href="classAString.html">AString</a></div><div class="ttdoc">Represents a Unicode character string.</div><div class="ttdef"><b>Definition</b> AString.h:38</div></div>
<div class="ttc" id="astructADataBindingDefault_html"><div class="ttname"><a href="structADataBindingDefault.html">ADataBindingDefault</a></div><div class="ttdoc">Defines how View handles properties of FieldType type.</div><div class="ttdef"><b>Definition</b> ADataBinding.h:37</div></div>
<div class="ttc" id="astructADataBindingDefault_html_a8b84a1211f21be11840c0f38d5d69c2a"><div class="ttname"><a href="structADataBindingDefault.html#a8b84a1211f21be11840c0f38d5d69c2a">ADataBindingDefault::property</a></div><div class="ttdeci">static auto property(const _&lt; View &gt; &amp;view)</div><div class="ttdoc">Returns property definition for FieldType.</div><div class="ttdef"><b>Definition</b> ADataBinding.h:49</div></div>
</div><!-- fragment --><p>We can use this predefined specialization to omit the destination property: </p><div class="fragment"><div class="line">_new&lt;ALabel&gt;() &amp; user-&gt;name</div>
</div><!-- fragment --><p>Behaviour of such connection is equal to <a class="el" href="#UIDataBindingTest_Label_via_declarative">Label via declarative</a>:</p>
<p><img alt="" class="inline" src="UIDataBindingTest.Label_via_declarative_1.png"/> </p>
<p>Note that the label already displays the value stored in User.</p>
<p>Let's change the name: </p><div class="fragment"><div class="line">user-&gt;name = <span class="stringliteral">"Vasil"</span>;</div>
</div><!-- fragment --><p><img alt="" class="inline" src="UIDataBindingTest.Label_via_declarative_2.png"/> </p>
<p>In this example, we've omitted the destination property of the connection while maintaining the same behaviour as in <a class="el" href="#UIDataBindingTest_Label_via_declarative">Label via declarative</a>.</p>
<h2>
ADataBindingDefault strong type propagation<a class="aui-toc-hash" href="#UIDataBindingTest_ADataBindingDefault_strong_type_propagation" id="UIDataBindingTest_ADataBindingDefault_strong_type_propagation" style="color: var(--fragment-comment) !important">#</a></h2>
<p><b aui-src="aui.uitests/tests/UIDataBindingTest.cpp#L622"></b> Think of <code><a class="el" href="structADataBindingDefault.html" title="Defines how View handles properties of FieldType type.">ADataBindingDefault</a></code> as we're not only connecting properties to properties, but also creating a "property to view" relationship. This philosophy covers the following scenario.</p>
<p>In AUI, there's <a class="el" href="structaui_1_1ranged__number.html" title="Clamps the possible values for a number to the specified range: [min;max].">aui::ranged_number</a> template which stores valid value range right inside the type: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>User {</div>
<div class="line">    <a class="code hl_class" href="structAProperty.html">AProperty&lt;aui::ranged_number&lt;int, 1, 99&gt;</a>&gt; age;</div>
<div class="line">};</div>
</div><!-- fragment --><p>These strong types can be used to propagate their traits on views, i.e., <a class="el" href="classANumberPicker.html" title="A text field for numbers with increase/decrease buttons.">ANumberPicker</a>. When using declarative syntax, the property system calls <code><a class="el" href="structADataBindingDefault.html#a55e3cde07f6e2fdbdd4dc0a15451e8cf" title="Called then view linked with field.">ADataBindingDefault::setup</a></code> to apply some extra traits of the bound value on the view. Here's an abstract on how <code><a class="el" href="classANumberPicker.html" title="A text field for numbers with increase/decrease buttons.">ANumberPicker</a></code> defines specialization of <code>ADataBingingDefault</code> with <code><a class="el" href="structaui_1_1ranged__number.html" title="Clamps the possible values for a number to the specified range: [min;max].">aui::ranged_number</a></code>: </p><div class="fragment"><div class="line"><span class="comment">/* PREDEFINED! You don't need to define it! This listing is an example */</span></div>
<div class="line"><span class="keyword">template</span> &lt;aui::arithmetic UnderlyingType, auto min, auto max&gt;</div>
<div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structADataBindingDefault.html">ADataBindingDefault</a>&lt;<a class="code hl_class" href="classANumberPicker.html">ANumberPicker</a>, aui::ranged_number&lt;UnderlyingType, min, max&gt;&gt; {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">auto</span> <a class="code hl_function" href="structADataBindingDefault.html#a8b84a1211f21be11840c0f38d5d69c2a">property</a>(<span class="keyword">const</span> <a class="code hl_class" href="class__.html">_&lt;ANumberPicker&gt;</a>&amp; view) {</div>
<div class="line">        <span class="keywordflow">return</span> view-&gt;<a class="code hl_function" href="class__.html#afca66562283bb9686c3c8a95bae5a42e">value</a>();</div>
<div class="line">    }</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code hl_function" href="structADataBindingDefault.html#a55e3cde07f6e2fdbdd4dc0a15451e8cf">setup</a>(<span class="keyword">const</span> <a class="code hl_class" href="class__.html">_&lt;ANumberPicker&gt;</a>&amp; view) {</div>
<div class="line">        view-&gt;setMin(aui::ranged_number&lt;UnderlyingType, min, max&gt;::MIN);</div>
<div class="line">        view-&gt;setMax(aui::ranged_number&lt;UnderlyingType, min, max&gt;::MAX);</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">};</div>
<div class="ttc" id="aclassANumberPicker_html"><div class="ttname"><a href="classANumberPicker.html">ANumberPicker</a></div><div class="ttdoc">A text field for numbers with increase/decrease buttons.</div><div class="ttdef"><b>Definition</b> ANumberPicker.h:24</div></div>
<div class="ttc" id="aclass___html_afca66562283bb9686c3c8a95bae5a42e"><div class="ttname"><a href="class__.html#afca66562283bb9686c3c8a95bae5a42e">_::value</a></div><div class="ttdeci">std::add_lvalue_reference_t&lt; T &gt; value() const noexcept</div><div class="ttdoc">Dereferences the stored pointer.</div><div class="ttdef"><b>Definition</b> SharedPtrTypes.h:294</div></div>
<div class="ttc" id="astructADataBindingDefault_html_a55e3cde07f6e2fdbdd4dc0a15451e8cf"><div class="ttname"><a href="structADataBindingDefault.html#a55e3cde07f6e2fdbdd4dc0a15451e8cf">ADataBindingDefault::setup</a></div><div class="ttdeci">static void setup(const _&lt; View &gt; &amp;view)</div><div class="ttdoc">Called then view linked with field.</div><div class="ttdef"><b>Definition</b> ADataBinding.h:43</div></div>
</div><!-- fragment --><p>As you can see, this specialization pulls the min and max values from <code><a class="el" href="structaui_1_1ranged__number.html" title="Clamps the possible values for a number to the specified range: [min;max].">aui::ranged_number</a></code> type and sets them to <code><a class="el" href="classANumberPicker.html" title="A text field for numbers with increase/decrease buttons.">ANumberPicker</a></code>. This way <code><a class="el" href="classANumberPicker.html" title="A text field for numbers with increase/decrease buttons.">ANumberPicker</a></code> finds out the valid range of values by simply being bound to value that has constraints encoded inside its type. </p><div class="fragment"><div class="line">_new&lt;ANumberPicker&gt;() &amp;&amp; user-&gt;age,</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>We're using <code>operator&amp;&amp;</code> here to set up bidirectional connection. For more info, go to <a class="el" href="#UIDataBindingTest_Declarative_bidirectional_connection">Declarative bidirectional connection</a>.</dd></dl>
<p>By creating this connection, we've done a little bit more. We've set ANumberPicker::setMin and ANumberPicker::setMax as well: </p><div class="fragment"><div class="line">EXPECT_EQ(numberPicker-&gt;getMin(), 1);</div>
<div class="line">EXPECT_EQ(numberPicker-&gt;getMax(), 99);</div>
</div><!-- fragment --><p>This example demonstrates how to use declarative binding to propagate strong types. <code><a class="el" href="structaui_1_1ranged__number.html" title="Clamps the possible values for a number to the specified range: [min;max].">aui::ranged_number</a></code> propagates its constraints on <code><a class="el" href="classANumberPicker.html" title="A text field for numbers with increase/decrease buttons.">ANumberPicker</a></code> thanks to <code><a class="el" href="structADataBindingDefault.html" title="Defines how View handles properties of FieldType type.">ADataBindingDefault</a></code> specialization.</p>
<h2>
Label via declarative projection<a class="aui-toc-hash" href="#UIDataBindingTest_Label_via_declarative_projection" id="UIDataBindingTest_Label_via_declarative_projection" style="color: var(--fragment-comment) !important">#</a></h2>
<p><b aui-src="aui.uitests/tests/UIDataBindingTest.cpp#L696"></b> We can use projections in the same way as with <code>let</code>. </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span>declarative;</div>
<div class="line"><span class="keyword">struct </span>User {</div>
<div class="line">    <a class="code hl_class" href="structAProperty.html">AProperty&lt;AString&gt;</a> name;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> user = <a class="code hl_function" href="structaui_1_1ptr.html#a9696eab52bd0745688055a301d9ef776">aui::ptr::manage</a>(<span class="keyword">new</span> User { .name = <span class="stringliteral">"Roza"</span> });</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyWindow: <span class="keyword">public</span> <a class="code hl_class" href="classAWindow.html">AWindow</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MyWindow(<span class="keyword">const</span> _&lt;User&gt;&amp; user) {</div>
<div class="line">        _&lt;ALabel&gt; label;</div>
<div class="line">        <a class="code hl_function" href="classAViewContainer.html#ab7bcd4a4bc08fc11c9bc1a9ff036f5e4">setContents</a>(Centered {</div>
<div class="line">            _new&lt;ALabel&gt;() &amp; user-&gt;name.readProjected(&amp;AString::uppercase)</div>
<div class="line">        });</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"><span class="keyword">auto</span> window = _new&lt;MyWindow&gt;(user);</div>
<div class="line">window-&gt;show();</div>
</div><!-- fragment --><div class="image">
<img alt="" src="UIDataBindingTest.Label_via_declarative_projection_1.png"/>
</div>
<p>Note that the label already displays the <b>projected</b> value stored in User.</p>
<p>Projection applies to value changes as well. Let's change the name: </p><div class="fragment"><div class="line">user-&gt;name = <span class="stringliteral">"Vasil"</span>;</div>
<div class="line"> </div>
<div class="line">EXPECT_EQ(user-&gt;name, <span class="stringliteral">"Vasil"</span>);</div>
<div class="line">EXPECT_EQ(label-&gt;text(), <span class="stringliteral">"VASIL"</span>); <span class="comment">// projected</span></div>
</div><!-- fragment --><div class="image">
<img alt="" src="UIDataBindingTest.Label_via_declarative_projection_2.png"/>
</div>
<h2>
Declarative bidirectional connection<a class="aui-toc-hash" href="#UIDataBindingTest_Declarative_bidirectional_connection" id="UIDataBindingTest_Declarative_bidirectional_connection" style="color: var(--fragment-comment) !important">#</a></h2>
<p><b aui-src="aui.uitests/tests/UIDataBindingTest.cpp#L825"></b> In previous examples, we've used <code>&amp;</code> to make one directional (one sided) connection. This is perfectly enough for <a class="el" href="classALabel.html" title="Represents a simple single-line text display view.">ALabel</a> because it cannot be changed by user.</p>
<p>In some cases, you might want to use property-to-property as it's bidirectional. It's used for populating view from model and obtaining data from view back to the model.</p>
<p>For this example, let's use <a class="el" href="classATextField.html" title="Editable field with text to receive a text input from the user.">ATextField</a> instead of <a class="el" href="classALabel.html" title="Represents a simple single-line text display view.">ALabel</a> as it's an editable view. In this case, we'd want to use <code>&amp;&amp;</code> because we do want <code>user-&gt;name</code> to be aware of changes of the view. </p><div class="fragment"><div class="line">_new&lt;ATextField&gt;() &amp;&amp; user-&gt;name</div>
</div><!-- fragment --><p>This gives the following result: <img alt="" class="inline" src="UIDataBindingTest.Declarative_bidirectional_connection_1.png"/> </p>
<p>Let's change the name programmatically: </p><div class="fragment"><div class="line">user-&gt;name = <span class="stringliteral">"Vasil"</span>;</div>
</div><!-- fragment --><p><a class="el" href="classATextField.html" title="Editable field with text to receive a text input from the user.">ATextField</a> will respond: <img alt="" class="inline" src="UIDataBindingTest.Declarative_bidirectional_connection_2.png"/> </p>
<p>If the user changes the value from UI, these changes will reflect on <code>user-&gt;model</code> as well: <img alt="" class="inline" src="UIDataBindingTest.Declarative_bidirectional_connection_3.png"/> </p>
<div class="fragment"><div class="line">EXPECT_EQ(user-&gt;name, <span class="stringliteral">"Changed from UI"</span>);</div>
</div><!-- fragment --><p>This way we've set up bidirectional projection via <code>&amp;&amp;</code> which makes <code>user-&gt;name</code> aware of UI changes.</p>
<h2>
Declarative bidirectional projection<a class="aui-toc-hash" href="#UIDataBindingTest_Declarative_bidirectional_projection" id="UIDataBindingTest_Declarative_bidirectional_projection" style="color: var(--fragment-comment) !important">#</a></h2>
<p><b aui-src="aui.uitests/tests/UIDataBindingTest.cpp#L890"></b> We can use projections in the same way as with <code>let</code>.</p>
<p>Let's repeat the <a class="el" href="#UIDataBindingTest_Bidirectional_projection">Bidirectional projection</a> sample in declarative way: </p><div class="fragment"><div class="line">_new&lt;ADropdownList&gt;(gendersStr) &amp;&amp; user-&gt;gender.biProjected(GENDER_INDEX_PROJECTION) &gt; &amp;<a class="code hl_function" href="classADropdownList.html#a943759a1bb9bb69a40ee9b2bca0ae088">ADropdownList::selectionId</a></div>
<div class="ttc" id="aclassADropdownList_html_a943759a1bb9bb69a40ee9b2bca0ae088"><div class="ttname"><a href="classADropdownList.html#a943759a1bb9bb69a40ee9b2bca0ae088">ADropdownList::selectionId</a></div><div class="ttdeci">auto selectionId() const</div><div class="ttdoc">Selected id property.</div><div class="ttdef"><b>Definition</b> ADropdownList.h:50</div></div>
</div><!-- fragment --><p><img alt="" class="inline" src="UIDataBindingTest.Declarative_bidirectional_projection_1.png"/> </p>
<dl class="section note"><dt>Note</dt><dd>We used the <code>&amp;&amp;</code> operator here instead of <code>&amp;</code> because we want the connection work in both directions: <code>user.gender -&gt; <a class="el" href="classADropdownList.html" title="A button with dropdown list.">ADropdownList</a></code> and <code><a class="el" href="classADropdownList.html" title="A button with dropdown list.">ADropdownList</a> -&gt; user.gender</code>.</dd></dl>
<ul>
<li>If we try to change <code>user-&gt;gender</code> programmatically, <a class="el" href="classADropdownList.html" title="A button with dropdown list.">ADropdownList</a> will respond: <div class="fragment"><div class="line">user-&gt;gender = Gender::FEMALE;</div>
<div class="line">EXPECT_EQ(dropdownList-&gt;getSelectedId(), 1); <span class="comment">// second option</span></div>
</div><!-- fragment --></li>
</ul>
<div class="image">
<img alt="" src="UIDataBindingTest.Declarative_bidirectional_projection_2.png"/>
</div>
<ul>
<li>If the user changes the value of <a class="el" href="classADropdownList.html" title="A button with dropdown list.">ADropdownList</a>, it reflects on the model as well: <div class="fragment"><div class="line">EXPECT_EQ(user-&gt;gender, Gender::OTHER);</div>
</div><!-- fragment --></li>
</ul>
<div class="image">
<img alt="" src="UIDataBindingTest.Declarative_bidirectional_projection_3.png"/>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">
Classes<a class="aui-toc-hash" href="#nested-classes" id="nested-classes" name="nested-classes" style="color: var(--fragment-comment) !important">#</a></h2></td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="structAProperty.html">AProperty&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">Basic easy-to-use property implementation containing T.  <a href="structAProperty.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="structAPropertyDef.html">APropertyDef&lt; M, Getter, Setter, SignalArg &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">Property implementation to use with custom getter/setter.  <a href="structAPropertyDef.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="structAPropertyPrecomputed.html">APropertyPrecomputed&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">Readonly property that holds a value computed by an expression.  <a href="structAPropertyPrecomputed.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classaui_1_1PropertyModifier.html">aui::PropertyModifier&lt; Property &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">Temporary transparent object that gains write access to underlying property's value, notifying about value changes when destructed.  <a href="classaui_1_1PropertyModifier.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<h2 class="groupheader">Function Documentation<a class="aui-toc-hash" href="#ga1eb0abe12d4d0c4db737cc63582791cd" id="ga1eb0abe12d4d0c4db737cc63582791cd" name="ga1eb0abe12d4d0c4db737cc63582791cd" style="color: var(--fragment-comment) !important">#</a></h2>

<h2 class="memtitle"><span class="permalink">◆ </span>biConnect()<a class="aui-toc-hash" href="#◆ biconnect()" id="◆ biconnect()" style="color: var(--fragment-comment) !important">#</a></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptAPropertyWritable.html">APropertyWritable</a> PropertySource, <a class="el" href="conceptAPropertyWritable.html">APropertyWritable</a> PropertyDestination&gt; <br/>
requires requires { { *propertySource } -&gt; <a class="el" href="conceptaui_1_1convertible__to.html">aui::convertible_to</a>&lt;std::decay_t&lt;decltype(*propertyDestination)&gt;&gt;; { *propertyDestination } -&gt; <a class="el" href="conceptaui_1_1convertible__to.html">aui::convertible_to</a>&lt;std::decay_t&lt;decltype(*propertySource)&gt;&gt;; }</div>
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">static void AObject::biConnect </td>
<td>(</td>
<td class="paramtype">PropertySource &amp;&amp;</td> <td class="paramname"><span class="paramname"><em>propertySource</em></span>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">PropertyDestination &amp;&amp;</td> <td class="paramname"><span class="paramname"><em>propertyDestination</em></span> )</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Connects <code>propertySource.changed</code> to the setter of <code>propertyDestination</code> . Additionally, sets the <code>propertyDestination</code> with the current value of the <code>propertySource</code> (pre-fire). Hence, initial dataflow is from left argument to the right argument.</p>
<p>After pre-fire, connects <code>propertyDestination.changed</code> to the setter of <code>propertySource</code> . This way, when <code>propertyDestination</code> changes (i.e, <code>propertyDestination</code> belongs to some view and it's value is changed due to user action) it immediately reflects on <code>propertySource</code> . So, <code>propertySource</code> is typically a property of some view model with prefilled interesting data, and propertyDestination is a property of some view whose value is unimportant at the moment of connection creation.</p>
<p>biConnect pulls <a class="el" href="classAObject.html" title="A base object class.">AObject</a> from <code>propertySource</code> and <code>propertyDestination</code> to maintain the connection.</p>
<p>See <a class="el" href="group__signal__slot.html">signal-slot system</a> for more info. </p><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">propertySource</td><td>source property, whose value is preserved on connection creation. </td></tr>
<tr><td class="paramname">propertyDestination</td><td>destination property, whose value is overwritten on connection creation. </td></tr>
</table>
</dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_27guis_2flight_booker_2src_2main_8cpp-example.html#a1">examples/7guis/flight_booker/src/main.cpp</a>, <a class="el" href="examples_27guis_2temperature_converter_2src_2main_8cpp-example.html#a2">examples/7guis/temperature_converter/src/main.cpp</a>, and <a class="el" href="examples_2app_2notes_2src_2main_8cpp-example.html#a16">examples/app/notes/src/main.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="ga9bae459e71bd485a16187caf26089228" name="ga9bae459e71bd485a16187caf26089228"></a>
<h2 class="memtitle"><span class="permalink">◆ </span>connect() <span class="overload">[1/3]</span><a class="aui-toc-hash" href="#◆ connect()-[1/3]" id="◆ connect()-[1/3]" style="color: var(--fragment-comment) !important">#</a></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptAAnyProperty.html">AAnyProperty</a> Property, typename Object, <a class="el" href="conceptACompatibleSlotFor.html">ACompatibleSlotFor</a>&lt; Property &gt; Function&gt; <br/>
requires (!<a class="el" href="conceptaui_1_1derived__from.html">aui::derived_from</a>&lt;Object, <a class="el" href="classAObject.html">AObject</a>&gt;)</div>
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">static void AObject::connect </td>
<td>(</td>
<td class="paramtype">const Property &amp;</td> <td class="paramname"><span class="paramname"><em>property</em></span>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="class__.html">_</a>&lt; Object &gt;</td> <td class="paramname"><span class="paramname"><em>object</em></span>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">Function &amp;&amp;</td> <td class="paramname"><span class="paramname"><em>function</em></span> )</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>See <a class="el" href="group__signal__slot.html">signal-slot system</a> for more info. </p><div class="fragment"><div class="line"><span class="keyword">struct </span>User { <a class="code hl_class" href="structAProperty.html">AProperty&lt;AString&gt;</a> name }; <span class="comment">// user.name here is non-AObject type</span></div>
<div class="line"><a class="code hl_function" href="group__signal__slot.html#ga4da6280feaeb063ce8e5b8a069755d6d">connect</a>(textField-&gt;text(), user-&gt;name.assignment());</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd><code>object</code> arg is accepted by value intentionally – this way we ensure that it would not be destroyed during connection creation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">property</td><td>source property. </td></tr>
<tr><td class="paramname">object</td><td>instance of <code><a class="el" href="classAObject.html" title="A base object class.">AObject</a></code>. </td></tr>
<tr><td class="paramname">function</td><td>slot. Can be lambda. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="ga01817340c5137752bbfb3eff5aed6857" name="ga01817340c5137752bbfb3eff5aed6857"></a>
<h2 class="memtitle"><span class="permalink">◆ </span>connect() <span class="overload">[2/3]</span><a class="aui-toc-hash" href="#◆ connect()-[2/3]" id="◆ connect()-[2/3]" style="color: var(--fragment-comment) !important">#</a></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptAAnyProperty.html">AAnyProperty</a> Property, <a class="el" href="conceptaui_1_1derived__from.html">aui::derived_from</a>&lt; <a class="el" href="classAObjectBase.html">AObjectBase</a> &gt; Object, typename Function&gt; </div>
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">static decltype(auto) AObject::connect </td>
<td>(</td>
<td class="paramtype">const Property &amp;</td> <td class="paramname"><span class="paramname"><em>property</em></span>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">Object *</td> <td class="paramname"><span class="paramname"><em>object</em></span>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">Function &amp;&amp;</td> <td class="paramname"><span class="paramname"><em>function</em></span> )</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Connects to "changed" signal of the property. Additionally, calls specified function with the current value of the property (pre-fire).</p>
<p>See <a class="el" href="group__signal__slot.html">signal-slot system</a> for more info. </p><div class="fragment"><div class="line"><a class="code hl_function" href="group__signal__slot.html#ga4da6280feaeb063ce8e5b8a069755d6d">connect</a>(textField-&gt;text(), <a class="code hl_define" href="group__signal__slot.html#gaaaa072876366972108aef016e7882a99">slot</a>(otherObjectRawPtr)::handleText);</div>
<div class="ttc" id="agroup__signal__slot_html_gaaaa072876366972108aef016e7882a99"><div class="ttname"><a href="group__signal__slot.html#gaaaa072876366972108aef016e7882a99">slot</a></div><div class="ttdeci">#define slot(v)</div><div class="ttdoc">Passes some variable and type of the variable separated by comma. It's convenient to use with the con...</div><div class="ttdef"><b>Definition</b> kAUI.h:88</div></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">property</td><td>property </td></tr>
<tr><td class="paramname">object</td><td>instance of <code><a class="el" href="classAObject.html" title="A base object class.">AObject</a></code> </td></tr>
<tr><td class="paramname">function</td><td>slot. Can be lambda </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="gae3434d972657abf3c93ade2536c06b08" name="gae3434d972657abf3c93ade2536c06b08"></a>
<h2 class="memtitle"><span class="permalink">◆ </span>connect() <span class="overload">[3/3]</span><a class="aui-toc-hash" href="#◆ connect()-[3/3]" id="◆ connect()-[3/3]" style="color: var(--fragment-comment) !important">#</a></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptAPropertyReadable.html">APropertyReadable</a> PropertySource, <a class="el" href="conceptAPropertyWritable.html">APropertyWritable</a> PropertyDestination&gt; <br/>
requires requires { { *propertySource } -&gt; <a class="el" href="conceptaui_1_1convertible__to.html">aui::convertible_to</a>&lt;std::decay_t&lt;decltype(*propertyDestination)&gt;&gt;; }</div>
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">static void AObject::connect </td>
<td>(</td>
<td class="paramtype">PropertySource &amp;&amp;</td> <td class="paramname"><span class="paramname"><em>propertySource</em></span>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">PropertyDestination &amp;&amp;</td> <td class="paramname"><span class="paramname"><em>propertyDestination</em></span> )</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Connects <code>propertySource.changed</code> to the setter of <code>propertyDestination</code> . Additionally, sets the <code>propertyDestination</code> with the current value of the <code>propertySource</code> (pre-fire). Hence, dataflow is from left argument to the right argument.</p>
<p>connect pulls <a class="el" href="classAObject.html" title="A base object class.">AObject</a> from <code>propertyDestination</code> to maintain the connection.</p>
<p>See <a class="el" href="group__signal__slot.html">signal-slot system</a> for more info. </p><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">propertySource</td><td>source property, whose value is preserved on connection creation. </td></tr>
<tr><td class="paramname">propertyDestination</td><td>destination property, whose value is overwritten on connection creation. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<p class="footer-inner">
    © 2025 AUI Framework Contributors. Documentation contributions included herein are the copyrights of their
    respective owners. The documentation provided herein is licensed under the terms of the GNU Free Documentation
    License version 1.3 as published by the Free Software Foundation. All trademarks are property of their respective owners.
</p>
</div><div class="contents-rails-right"><div class="aui-toc"><p>Contents</p><h1><a href="#detailed-description">Detailed Description</a></h1><h1><a href="#declaring-properties">Declaring Properties</a></h1><h1><a href="#ui-data-binding-with-let">UI data binding with let</a></h1><h2><a href="#UIDataBindingTest_Label_via_let">Label via let</a></h2><h2><a href="#UIDataBindingTest_Label_via_let_projection">Label via let projection</a></h2><h2><a href="#UIDataBindingTest_Bidirectional_connection">Bidirectional connection</a></h2><h2><a href="#UIDataBindingTest_Bidirectional_projection">Bidirectional projection</a></h2><h1><a href="#UI_declarative_data_binding">UI declarative data binding</a></h1><h2><a href="#UIDataBindingTest_Label_via_declarative">Label via declarative</a></h2><h2><a href="#UIDataBindingTest_ADataBindingDefault_for_omitting_view_property">ADataBindingDefault for omitting view property</a></h2><h2><a href="#UIDataBindingTest_ADataBindingDefault_strong_type_propagation">ADataBindingDefault strong type propagation</a></h2><h2><a href="#UIDataBindingTest_Label_via_declarative_projection">Label via declarative projection</a></h2><h2><a href="#UIDataBindingTest_Declarative_bidirectional_connection">Declarative bidirectional connection</a></h2><h2><a href="#UIDataBindingTest_Declarative_bidirectional_projection">Declarative bidirectional projection</a></h2><h1><a href="#nested-classes">Classes</a></h1><div class="aui-toc-extras"><a href="javascript:jumpToSource('view')"><i class="fa fa-file"></i>View Page Source</a><a href="javascript:jumpToSource('edit')"><i class="fa fa-edit"></i>Edit Page Source</a></div></div></div></div><!-- doc-content -->
<!-- HTML footer for doxygen 1.12.0-->
<!-- start footer part -->
</div></body>
</html>
